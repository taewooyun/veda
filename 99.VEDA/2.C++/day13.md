## 복사 생성자

- 다수 객체 생성
    - 초기화 코드가 있는 멤버 변수의 값을 변경하려면 함수 호출 또는 값 대입 필요
    - 설정 값이 조금씩 다른 몇 십 개의 객체 생성이 매우 번잡스럽게 작업해야 함
- 복사 생성자
    - 초기화가 아닌 객체를 복사할 때의 값들을 복사해서 이미 설정된 값을 사용해 객체를 새롭게 생성함
    - 동일한 설정값은 추가적인 설정이 필요 없음, 차이나는 멤버 변수 값만 설정함

### 얕은 복사와 깊은 복사

- 얕은 복사 : monster_a = monster_b;
- 깊은 복사 :
    
    MonsterB::MonsterB(const monsterb &ref) : member1(value), member2(value) {
    
    member3 = new char[1024];
    
    }
    
    - 생성자에 해당 클래스를 파라미터로 받아서 멤버 타입에 따라 동적할당 및 초기화

## 소멸자

- 소멸자는 생성자와 반대 역할
    - 객체가 소멸할 때 필요한 메모리 해제나 환경을 이전 상태로 변경하는 등의 일을 진행
    - 생성자와 비슷하게 소멸될 때 자동으로 호출 됨
- 기본 소멸자
    - 이름은 클래스 이름과 같게 작성하고 이름 앞에 물결표를 추가
    - 소멸자는 기본 소멸자 이외에 소멸자를 만들 수 없음
    - 다중 상속인 경우 소멸자는 생성자 호출의 역순으로 호출 됨
- 가상 소멸자
    - 업캐스팅으로 소멸자가 실행되면 자식의 소멸자는 호출되지 않는다
        
        → virtual 키워드로 소멸자도 오버라이딩되어 자식과 부모 둘다 호출하게 함
        

## 함수와 연산자 오버로딩

### 연산자 오버로딩

- 포맷
    - 반환형식 operator연산자기호(매개변수)
- this를 활용하기 때문에 피연산자 하나만 매개변수로 가질 수 있게 됨

## 접근 지정자와 프렌드

- 멤버 변수를 정의하거나 상속받을 때 주로 사용
- 클래스 멤버 선언부에서 public, private, protected 키워드와 콜론
- 클래스 외부에서 클래스 멤버 함수. 변수를 사용 제어

### 상속에 따른 접근 지정자의 변화

- 상속 접근 지정자
    - 상속 받은 멤버의 접근 지정자 변경
    - 상속 접근 지정자에 따라 다르게 변경
- 상속 접근 지정자 생략
    - 기본 접근 지정자 사용
    - C++에서 기본 접근 지정자는 private
    - 구조체의 기본 접근 지정자는 public
    - 포맷
        - class Child : public Parent{}
- 상속 접근 지정자
    - 자식 클래스에 적용되는 접근 지정자
        - 해당 키워드 까지로 설정됨
            
            ex) protected Parent : parent의 모든 멤버(public, protected, private)가 protected(protected, private) 이하로 설정 됨
            

# 객체지향을 돕는 기능들

### 다중 상속의 단점

- 클래스가 커지는 문제
    - 클래스가 다양한 역할을 수행하게 되는 거대 클래스는 지양
        - 속성과 기능이 많아 사용하기가 어렵고, 부모 클래스가 변경되면 상속받은 모든 클래스에 영향
        - 변경 사항이 여러 곳에 영향을 주므로 바람직하지 않음
    - 상속이나 사용 관계로 의존도가 높아지면 결합도가 높아짐
        - 소스 코드는 결합도가 낮을수록 유지 보수가 수월
- 컴파일 시간이 늘어나는 문제
    - 소스 코드가 변경되면 컴파일 재실행
        - 오픈소스처럼 클래스 파일이 수 만 개라면 몇 시간이 소요
    - 변경된 부분만 재 컴파일 하지만 결합도가 높으면 적은 수정에도 많은 수의 파일 컴파일이 진행됨

## 컴포지션과 어그리게이션

- 멤버 변수로 포함하여 클래스를 재사용 → 코드를 직접 사용하지 않아 변경 시 재 컴파일 없음
- 클래스는 단일 속성과 기능을 가지므로 결합도는 낮아지고, 변경에 따른 영향이 적어짐
- 컴포지션(part-of)은 포함, 어그리게이션(has-a)은 사용의 개념

### 컴포지션(Composition)

- 상속이 아닌 멤버 변수로 포함
    - 재사용할 속성과 기능을 별도로 분리하여 해당 객체를 멤버 변수로 포함(’part-of’) 포함한 클래스에 종속됨
    - 생명주기를 포함한 클래스가 관리하기 때문에 두 클래스의 생명주기가 동일함

### 어그리게이션(Aggregation)

- 상속이 아니라 멤버 변수로 포함
    - 분리된 클래스의 객체를 포인터나 레퍼런스 변수로 포함, 분리된 클래스를 가지고(’has-a’) 사용
    - 클래스와 유연한 관계르 생명주기가 다름. 클래스를 직접 참조하거나, 상속받은 자식 클래스를 참조

## 가상 함수와 동적 바인딩

### 가상 함수란

- 멤버 함수 가운데 자식 클래스에서 오버라이딩(재정의)해야 하는 함수
    - 또는 오버라이딩 하기를 기대하는 함수
- 일반 멤버 함수도 자식 클래스에서 오버라이딩 할 수 있음
    - 오버라이딩이 필요하다는 의미를 전달할 수 없음 → 문법적으로 명확하지 않음
    - 부모 클래스로 업캐스팅 시 호출되는 함수가 다름 → 다향성 구현의 원리
- 가상 함수 호출의 원리
    - 가상 함수 테이블을 활용해 동적으로 바인딩
- 바인딩
    - 함수 호출이나 변수 참조가 동작 코드와 연결되는 과정
        - 프로그램 실행은 메모리를 이동하면서 실행이 되는데 실행 코드 메모리를 연결하는 과정임
    - 바인딩은 정적 바인딩과 동적 바인딩 두 가지 종류가 있음
        - 각각 이른 바인딩, 늦은 바인딩 이라고도함
    - 정적 바인딩은 컴파일 시점에 동작
        - 정적으로 바인딩되는 대상은 컴파일할 때 결정되어 프로그램이 실행되는 동안 유지
        - 일반 변수와 함수, 배열과 템플릿 등

### 함수의 동적 바인딩

- 동적 바인딩
    - 대상이 실행 시점에 결정되며 변경될 수 있음
    - 가상 함수, 자식 클래스로 치환된 부모 클래스의 포인터가 동적 바인딩의 대표 예
- 동적으로 바인딩된 대상은 프로그램이 실행되는 동안에 수시로 변경

### 가상 함수 테이블

- 클래스 계층 구조 최상위에 존재하는 가상 함수에 대한 메모리 정보
- 업캐스팅 후에도 자식테이블이 호출될 수 있도록 정보 제공하는 구조
- 가상함수가 있는 객체를 생성하면 가상 함수 테이블을 가리키는 포인터(_vfptr)생성
    - 가상 함수를 호출 시 _vfptr을 활용, 가상 함수의 개수에 따라 _vfptr 크기가 변경됨

### 순수 가상 함수

- 부모 클래스에서는 가상 함수는 정의 없이 선언만 진행
- 자식 클래스에서 반드시 재정의해야 한다는 것을 문법적으로 알림
- 순수 가상 함수로 명시적으로 남겨 둘 수도 있음(순수 가상 함수로 다시 선언)
- 포맷
    - virtual void function(parameter) = 0;

### 가상 소멸자

- 업캐스팅 된 객체의 소멸시 문제 발생
    - 소멸자는 메모리 해제 등 리소스 정리를 위해서 사용 됨
    - 업캐스팅 된 상태의 객체의 메모리가 해제 될 때 소멸자 호출은?
        - 업캐스팅 되지 않은 객체는 객체에서 정의한 소멸자, 부모 클래스의 소멸자 순으로 호출됨
    - 업캐스팅 된 경우 업캐스팅 된 클래스의 범위에서 소멸자가 호출됨
        - 업캐스팅된 객체의 소멸자는 호출 되지 않음

## 추상 클래스

- 순수 가상함수로만 이루어진 클래스 → 객체를 만들 수 없다
- 추상 클래스(abstract class) ↔ 구상 클래스(concrete class) : 구현된 클래스
- Concrete class
    - 객체를 만들 수 있는 클래스

### 디자인 패턴

- 전략 패턴

## 정적 멤버

- static은 this를 사용할 수 없다
- 정적 멤버 변수
    - 범위 지정자가 적용된 정적 변수, 같은 클래스에서 만들어진 객체에서 공유하는 값
    - 또는 외부에서 참고할 수 있는 동일 클래스로 선언된 객체들의 값
- 정적 멤버 함수
    - 클래스의 객체를 클래스 내부에서 직접 관리하고 싶을때, 또는 유틸리티 함수를 만들 때 활용
    - 유틸리티 함수란, 문자열 조작, 날짜나 시간 계산 , 수학적 계산 등 특정 작업을 지원하는 함수
        - ex) 행렬, 벡터 연산을 하는 선형대수의 연산자 정의 시 :
            
            연산자들은 행렬, 벡터만을 매개변수로 사용,
            
            범위 연산자로 선형대수와 관련된 함수임을 명시적으로 표현
            
            행렬, 백터 연산이 필요할 때마다 객체를 생성하는 번거로움이 없음
            
    - 객체를 크래스 내부에서 직접 관리하는 예시 → 팩토리 패턴
        - ex) 몬스터 객체를 생성하는 클래스 멤버를 정적 멤버 함수로 정의

# 객체지향 설계 원칙

## SOLID 원칙

- 로버트 C. 마틴이 2000년대 초반에 발표한 객체지향 설계의 다섯가지 원칙
- 마이클 C. 페더스가 부르기 쉽게 머리글자로 소개한 것
- SOLID
    - Single Responsibility Princibple(SRP) : 단일 책임 원칙
    - Open-Closed Principle(OCP) : 개방 폐쇄 원칙
    - Liskov Subsititution Principle(LSP) : 리스코프 치환 원칙
    - Interface Segregation Principle(ISP) : 인터페이스 분리 원칙
    - Dependency Inversion Priciple(DIP) : 의존성 역전 원칙

### Single Responsibility Principle

- ‘클래스는 한 가지 기능만 수행해야하고, 한가지 이유로만 변경해야한다’ 는 원칙
- 산탄총 수술
    - 한 가지 기능을 수정할 때 클래스를 여러개 수정해야 한다면 유지, 보수성은 떨어지기 마련
    - 이러한 현상을 ‘산탄총 수술(shotgun sergery) 이라고함. 탄흔을 사방에 남긴다는 의미
- 단일 책임 원칙을 만족(구현)시킬 수 있는 객체지향 프로그래밍의 특성
    - 클래스 추출 : 리팩터링
    - 상속 관계 보다는 composition(구성), aggregation(소유) 적극 활용
    - 구성 : part-of, 멤버 변수로 포함시켜 생명주기를 같이 가짐
    - 소유 : has-a, 멤버 변수로 참조 시켜 생명주기를 따로 가짐

### Open-Closed Principle

- 확장에 열려(개방) 있고 수정에 닫혀(폐쇄)있어야 한다
- 개방 폐쇄 원칙을 만족(구현)시킬 수 있는 객체지향 프로그래밍의 특성
    - 동적 바인딩
        - 새로운 기능을 언제든 추가할 수 있음(확장에 개방)
        - 다른 코드에 영향을 주지 있지 않아 추가되는 기능 외에는 수정이 필요 없음(수정에 폐쇄)
    - 추상 클래스 활용
        - 새로운 자식 클래스를 추가할 수 있어도 기존 부모 클래스들에는 영향을 주지 않음
        - 템플릿 메서드 패턴

### Liskov Substitution Principle

- 하위 클래스는 상위 클래스를 대체할 수 있어야 한다는 의미
    - 바바라 리스코프 OOPSLA’87 기조 연설 ‘Data abstraction and hierachy’
    - 다형성의 동작 원리를 설명
- 리스코프 치환 원칙을 만족(구현)시킬 수 있는 객체지향 프로그래밍의 특성
    - 자식 클래스가 부모 클래스를 치환
    - 부모 클래스의 역할을 자식 클래스가 수행할 수 있음
        
        → 업캐스팅 등
        
    - 자식 클래스가 부모 클래스를 완전히 대체할 수 있는 ‘is-a’ 관계

---

## 자습

- 포인터 배열 동적 할당
- 주소연산자가 두개일 때
- 4바이트 할당과 8바이트 할당 메모리 차이
- 업캐스팅과 리스코프치환원칙
- 교재 p334~
- 디자인 패턴
    - 팩토리, 전략 패턴
    - 템플릿 메서드 패턴
- LSP 와 ISP 예시
    
    [내용](https://www.notion.so/2a12071f55fa80f28ed3eb4970ca60a6?pvs=21)
    

## 교과 평가

C : ~ 10장