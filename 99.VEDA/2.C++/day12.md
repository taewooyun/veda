# 상속성과 다형성

## 상속

- 클래스를 만들 때 다른 클래스의 멤버 함수, 멤버 변수를 물려받는 것
- 이미 추상화, 캡슐화된 클래스를 확장하고, 변형하는 방법

## 상속성이란?

- 클래스 치환
    - 상속의 중요한 여러 특성 중 하나, 다형성의 기반이 되는 특성
    - 의미 : 자식  크래스는 부모 클래스를 대체할 수 있음
- 자식 클래스가 부모 클래스의 속성과 기능을 변경하면 안됨
    - 부모 클래스가 public으로 선언한 함수의 시그니처를 변경 없이 상속받아야 함

## 다형성이란?

- 상속 받은 자식 클래스들이 부모와 다른 다양한 특성을 가지는 것
    - 동일한 함수가 부모와 다른 행동 방식으로 동작하는것
    - 상위 개념의 역할을 대신할 수 있으면서 각자의 고유한 특징으로 동작하는 것
- childClass.ParentClass::getArea(); // 자식 객체의 부모 멤버 함수 호출

## 클래스의 메모리상 구조

- instance table : 멤버 변수를 저장 - local value?
- function table : 멤버 함수를 저장
- string table : 상수 문자열 값을 저장
- vtable : virtual 함수 주소를 저장

## 실행 파일 추출 단계

1. 컴파일
2. 링크
    
    → 정적 바인딩
    
3. 런타임
    
    → 동적 바인딩
    

런타임에는 실행을 하면서 코드 세그먼트에 필요한 모든내용을 올려놓은 상태에서 실제적으로 스택과 힙에 객체를 생성하면서 코드가 실행됩니다 객체가 만들어지고 객체가 포인터변수에 대입되기까지는 런타임이건 컴파일 타임이건 똑같이 해석이 될 수 있지만 함수를 호출할 때 달라진다.

함수를 호출할때 주소가 결정되는것을 런타임바인딩이라하고 런타임 바인딩은 버추얼일때만 동작한다.

- virtual이 붙으면 런타임안에 vtr_ptr 공간이 생긴다

### 포인터 변수와 참조 변수의 차이

- 포인터는 런타임에 변수를 찾아가기위히 필요한 스택이 생긴다
- 참조 변수는 공간이 따로 안생기고 로컬 배리어블 테이블에만 있다

## 객체지향의 특징 정리

- 객체지향 특징을 잘 활용하면 유지 보수성이 뛰어난 프로그램을 만들 수 있음
    - 확장에는 열려있고 수정에는 닫혀있다

---

## 자습

- 객체지향 프로그래밍의 특징에 대한 단계
- 생성자 람다인가?
    - MyClass() : hp(100), power(100){};
- cpp과 자바의 차이
    - 자바는 모든 객체 변수가 참조기반
    - cpp는 값/참조 구분
- MyClass* MyClass::get_class(){ } // 표현법 확인
- namespace와 class의 차이
- 클래스의 메모리상 구조 전체
    - obj 파일의 구조
- 링커의 역할
    - obj파일을 묶어줌 + 라이브러리 중 사용한 함수만 컴팩트하게 합쳐줌
        
        → 용량 최적화 후 실행파일을 만들어 준다
        
- 업캐스팅 될 때 생성자 호출
    - 상속했으면 부모 호출 다 되는건가?
- 참조 변수는 담는 변수가 포인터던 아니던 참조 변수를 사용할 때 멤버 접근에 스타 개념이 필요 없는가?
- 생성자 초기화 리스트
    - 생성자 함수만 사용 가능하다
-