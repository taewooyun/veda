## 실시간 시스템
실시간 시스템은 빠른(Fast) 시스템이 아니라 예측가능한(Predictable) 시스템이다

#### 비실시간(Non-Real-Time)
반복 실행마다 응답 시간이 크게 변동 ⇒ 신뢰할 수 없음
“시스템 부하가 높아 오래 걸렸다가, 부하가 낮아 빨리 끝나는” 식으로 예측 불가능
#### 실시간(Real-Time)
조건이 달라져도 반복(iteration)마다 응답 시간이 일정 ⇒ 타이밍을 기한 내에 반드시 지킴

#### 실시간 애플리케이션(RTA, Real-Time Application)의 특징
속도가 아닌 ‘타이밍 보장’이 핵심
단순히 빠른 처리(Fast)는 실시간 요건 충족과 무관
하드웨어 성능과 상관없이 시간 요구사항(Deadline)을 정확히 지켜야 실시간
시간 결정성(Time Deterministic)
이벤트 발생 시 “항상 일정한(Response Time)”으로 처리
소소한 변동 정도는 소프트 실시간(Soft RT) 범주에 들고, 기한을 절대 넘어서는 경우 하드 실시간(Hard RT) 실패로 간주

하드 실시간 vs 소프트 실시간
구분 특성 실패 시 영향

#### 하드 실시간(Hard RT)
- 기한을 절대 준수해야 함 (Deadline1회라도 지키지 못하면 시스템 실패)
- 치명적 사고, 심각한 시스템 전체 불능
#### 소프트 실시간(Soft RT)
- 소폭 지연(수~수십 ms) 정도는 허용, 데드라인 준수 실패가 치명적 결과까지 이어지진 않음
- 약간의 품질 저하(렉·지연·프레임 드롭), 사용자 체감이 미미

### 주요 실시간 애플리케이션 사례
#### 하드 실시간(Hard RT)
- 자동차 에어백(Airbag) 제어: 충돌 감지 → 지정된 ms 내에 에어백 팽창
- ABS(Anti-Lock Braking System): 브레이크 잠김 방지 즉시 제어
- 항공기 비행 제어(FMC): 센서 → 제어로직 → 조종면 구동까지 일정 시간 이내 처리
- 미사일 유도·제어: 목표에 빗나가지 않도록 정해진 주기로 궤적 계산
#### 소프트 실시간(Soft RT)
- VoIP(Voice over IP): 음성 패킷 지연·손실이 일부 발생해도 사용자가 잘 못 느끼면 무방
- 미디어 스트리밍(비디오/게임 서버): 약간의 프레임 드롭이나 렉은 허용
- ATM(현금자동인출기): 수백 ms 정도 지연되더라도 시스템 작동 자체는 가능
- 일부 로봇 제어: 인간 눈에 보일 정도의 약간의 지연은 용인 가능


## 실시간/범용 OS 비교 및 대표 RTOS
### 실시간 OS(RTOS)의 핵심 특성
#### 최대 수행 시간(Deterministic Bound) 보장
- 각 핵심 작업(인터럽트 처리, 태스크 전환, 시스템 콜 등)에 대해 알려진 최대 지연 시간을 갖는다
#### 짧고 예측 가능한 인터럽트 지연(Interrupt Latency)
- 가능한 한 인위적 지연을 최소화해 즉시 응답
#### 간단한 우선순위 기반 스케줄러
- 높은 우선순위 태스크가 즉시 실행되도록 설계
- 우선순위 역전(Priority Inversion)을 방지하기 위한 기법(PIM, Ceiling Protocol 등)을 제공
#### 짧은 크리티컬 섹션
인터럽트를 장시간 금지하지 않으며, 불필요한 임계 구간 코드를 최소화

#### GPos vs RTos

| 구분      | GPOS (일반 OS)                        | RTOS (실시간 OS)                              |
| ------- | ----------------------------------- | ------------------------------------------ |
| 목적      | 다목적 (멀티미디어, 오피스, 서버 등)              | 실시간 제어·임베디드 시스템                            |
| 스케줄링    | 복잡·공정성 중심, 태스크 실행 시간 예측 불가          | 우선순위 기반·단순, 지연 시간 결정적                      |
| 인터럽트    | 지연 시간 보장 어려움                        | 짧고 예측 가능한 최대 지연 시간 보장                      |
| 크리티컬 섹션 | 긴 임계 구역 코드 허용                       | 인터럽트 금지 구역 최소화                             |
| 예시 OS   | Windows, Linux, macOS, Android, iOS | FreeRTOS, VxWorks, QNX Neutrino, Integrity |

### 대표적인 RTOS 예시
#### VxWorks (Wind River)
- 범용 산업용·안전·보안·IoT 분야
- 상용(유료 라이선스)
#### QNX Neutrino (BlackBerry/QNX)
- 산업 자동화, 의료, 로보틱스
- 상용(유료 라이선스)
#### FreeRTOS (Amazon Web Services)
- 오픈소스(무료), 로열티 프리
- “OpenRTOS”와 “SafeRTOS” 두 가지 에디션 (보안·안전 기능 추가판)
- 조건별 다양한 마이크로컨트롤러 보드 지원
#### Integrity (Green Hills Software)
- 보안·안전 크리티컬 시스템 전용
- 상용(유료 라이선스)


### RTOS vs GPOS: 우선순위 역전(Priority Inversion) 개념

#### 우선순위 역전 : Priority Inversion
1. 낮은 우선순위 태스크가 자원을 쥔 채 멈추고
2. 중간 우선순위 태스크가 CPU를 차지해서
3. 높은 우선순위 태스크가 실행되지 못하는 현상 : Blocked


#### GPOS vs RTOS에서의 우선순위 역전

구분 | GPOS | RTOS
 --- | --- | ---
스케줄링 특성 |	복잡·공정성 중심 | 우선순위 최대치 보장
역전 방지 기능 |대부분 없음	| 다양(뮤텍스 우선순위 상속, 뮤텍스 우선순위 천장 등)
결과 | 우선순위 역전이 장시간 지속될 수 있음고우선순위 태스크 기한 미준수 위험	| 우선순위 역전이 짧게 끝나도록 설계됨고우선순위 태스크 기한 보장


### RTOS에서의 우선순위 역전 해결 기법
#### 1. 우선순위 상속(Priority Inheritance)
- 동작 원리:
    - 저우선순위 L이 공유 자원 확보 시 L에 걸려 있는 잠금 뮤텍스를 H가 대기하면 L이 가진 실제 실행 우선순위를 H 수준(또는 그 위)까지 잠시 상승
- 효과:
    - L이 CPU를 더 오래 점유 → M이 실행되지 못하고 대기
    - 곧 L이 공유 자원을 해제 → 우선순위가 원래대로 돌아가고, H가 즉시 실행
- 장점: 단기 우선순위 조정으로 H의 대기 시간을 줄여 “시간 결정성(Determinism)” 확보
- 단점: 우선순위 변경·복원 관리 오버헤드가 있으나, 실시간 보장에 절대 필요
#### 2. 우선순위 천장(Priority Ceiling) / 우선순위 역전 방지(Priority Ceiling Protocol)
- 동작 원리:
    - 공유 자원을 사용하기 전에, 해당 자원이 사전에 정의된 “천장 우선순위(Priority Ceiling)”까지 자신(태스크)의 우선순위를 즉시 상승
- 효과:
    - 자원을 획득하기 전부터 “최대 우선순위” 상태가 되므로, M(중간 우선순위)은 물론이고 H(고우선순위)가 대기 중이라도 자원을 해제할 때까지 L이 CPU를 잃지 않음
    - 자원 해제 후에 우선순위가 원상복구되며, H→또는 M이 순서대로 실행
- 장점: “무한 대기(Infinite Blocking)” 방지, H가 오랫동안 지연되지 않도록 보장
- 단점: 자원별 우선순위 천장을 사전에 정의해야 하며, 시스템 설계가 복잡해질 수 있음

> 우선순위 상속은 중간 우선순위 태스크가 개입할 수 있는 타임 윈도우가 존재해 우선순위 천장보다 실시간 보장성이 낮다. 반면 우선순위 천장은 보장성은 높지만 구현 난이도와 오버헤드가 크므로 시스템 요구사항에 따라 적절한 방식을 선택해야 한다.

> 우선순위 천장은 자원별 최대 우선순위를 사전에 정의하고 자원 중첩 및 데드락 방지 규칙까지 함께 고려해야 하므로 설계·구현·검증 난이도가 우선순위 상속보다 높다.


## RTOS vs GPOS: 태스크 스케줄링 관점 비교

### 1. GPOS(일반 목적 OS)의 스케줄링
#### 목표:
가능한 한 많은 프로세스를 최대한 빠르게 처리하여 **높은 처리량(Throughput)**을 달성
- 처리량 = 단위 시간당 완료된 프로세스 수
#### 스케줄링 정책:
공정성(fairness)에 방점을 두고, 준비 큐에 있는 여러 태스크를 골고루 배분
- “낮은 우선순위 작업 5–6개를 처리하는 편이 높은 우선순위 작업 1개만 처리하는 것보다 전체 완료 수가 높다”는 관점
- 따라서 시스템 부하가 높으면, 높은 우선순위 태스크조차도 잠시 대기시키고 일시적으로 낮은 우선순위 태스크를 먼저 처리할 수 있음
#### 장점:
데스크톱·서버 환경에서 사용자 편의나 배치 작업, 멀티미디어 스트리밍 등 **“전체 처리량”**을 극대화
#### 단점:
우선순위 보장 없음 → “시급한 고우선순위 작업이 곧바로 실행된다”는 보장이 없다
실행 지연(latency)이 예측 불가능해, 실시간 요건(Time‐Critical Deadline) 충족 불가

### 2. RTOS(실시간 OS)의 스케줄링
#### 목표:
모든 태스크의 데드라인(deadline) 준수 보장 → “반드시 정해진 시간 안에 처리”
#### 스케줄링 정책:
우선순위 우선 처치(Priority‐Based Preemptive Scheduling)
- 태스크 우선순위가 높을수록 언제든 즉시 실행
- 낮은 우선순위 태스크는 실행 중에도, 더 높은 우선순위 태스크가 “준비 상태(Ready)”가 되면 즉시 선점(Preempt) 당함
- 최상위 우선순위 태스크가 없으면, 그다음 우선순위 태스크가 실행
#### 특징:
- “높은 우선순위 태스크 우선 보장” → 시간 결정성(Determinism)을 확보
- 만약 더 높은 우선순위 작업이 출현하면, 그 즉시 CPU 제어권을 넘겨주어 기한 준수를 최우선
#### 장점:
- 하드 실시간 요건에서도 예측 가능한 최대 지연 시간(Interrupt Latency, Context Switch Time) 보장
- 태스크 응답 시간(Response Time)이 “거의 일정하게” 유지되어, 기한을 놓치지 않음
#### 단점:
- 낮은 우선순위 태스크들은 제출만 해 두고 상당 시간 대기할 수 있음(Starvation 위험)
- 전체 시스템 처리량(Throughput)은 GPOS보다 상대적으로 낮을 수 있음
그러나 대부분 RTOS 환경에서는 “실시간 기한 준수를 위해 태스크 개수 자체가 적음(임베디드 시스템 특성)”
따라서 상대적으로 낮은 부하 하에서도 충분한 처리량을 확보하면서 “시간 결정성”을 달성


### 요약 표

항목                |               GPOS (General-Purpose OS)    |                   RTOS (Real-Time OS)
--- | --- | ---
주요 목표 |	높은 처리량(Throughput)	| 시간 결정성(Time-Determinism; Deadline 보장)
스케줄링 정책 |	공정성 기반 스케줄러(Fair-Share, Round-Robin 등)  |	우선순위 기반 선점 스케줄러(Higher Priority Preempts)
우선순위 보장 |	없음(고우선순위 작업도 대기될 수 있음) |	항상 보장(더 높은 우선순위 등장 시 즉시 선점)
인터럽트 지연 |	예측 불가, 일시적으로 긴 지연 발생 가능 |	짧고 예측 가능한 최대 지연 시간 보장
임계 구역(Critical Section) |	길고 복잡해도 허용 |	가능한 한 짧게 유지하여 지연 최소화
처리량(Throughput) |	매우 높음(다수 태스크 동시 처리에 최적화) |	상대적으로 낮을 수 있으나, 실시간 요구에 최적화(부하 자체가 적음)
사용 예시 |	데스크톱, 스마트폰(일반 앱), 서버, PC 애플리케이션 |	산업용 제어, 항공·자동차 안전 시스템, 의료기기, 로봇 등 실시간 제어

#### 임계 구역
- 락·인터럽트 비활성화 등으로 인해 선점이 불가능해지는 모든 코드 구간
- RTOS에서는 이 길이가 곧 실시간 성능의 한계

















--- 

#### CMSIS란?
CMSIS = Cortex Microcontroller Software Interface Standard

ARM이 만든 표준 소프트웨어 인터페이스 규격
→ Cortex-M 계열 MCU에서 하드웨어·RTOS·툴 체인을 통일하려는 목적