### mutex를 사용할 때 주의해야할 점
아주 좋은 질문이야.
**“mutex를 쓸 줄 안다”와 “제대로 쓴다”의 차이**가 여기서 갈려 👍
로그 예제 기준으로 **실무에서 꼭 알아야 할 주의사항**만 정리해줄게.

---

## 1️⃣ lock / unlock 직접 쓰지 말 것 ❌

### ❌ 위험한 코드

```cpp
logMutex.lock();
doSomething();
if (error) return;   // unlock 안 됨 → 데드락
logMutex.unlock();
```

### ⭕ 안전한 방식

```cpp
std::lock_guard<std::mutex> lock(logMutex);
doSomething();
```

📌 **RAII 무조건 사용**

---

## 2️⃣ 임계 영역은 최소한으로 ⚠️

### ❌ 나쁜 예

```cpp
std::lock_guard<std::mutex> lock(logMutex);
heavyCalculation();
writeLog();
```

### ⭕ 좋은 예

```cpp
heavyCalculation();

{
    std::lock_guard<std::mutex> lock(logMutex);
    writeLog();
}
```

👉 **lock 잡고 있는 시간 = 짧을수록 좋음**

---

## 3️⃣ mutex 안에서 또 다른 mutex 잡지 말 것 (중요)

### ❌ 데드락 위험

```cpp
lock(mutexA);
lock(mutexB);
```

다른 스레드:

```cpp
lock(mutexB);
lock(mutexA);
```

👉 **교착 상태(Deadlock)**

### ⭕ 규칙

* mutex 순서 고정
* 가능하면 **하나만 사용**

---

## 4️⃣ 로그 안에서 로그 찍지 말 것 ❌

### ❌ 치명적 실수

```cpp
std::lock_guard<std::mutex> lock(logMutex);
logMessage("에러 발생");  // 자기 자신 호출 → 데드락
```

### ⭕ 규칙

* mutex 보호 함수 안에서는
* 같은 로그 함수 호출 금지

---

## 5️⃣ 예외 발생 가능 코드 주의 ⚠️

* 파일 I/O
* filesystem
* 메모리 할당

👉 `lock_guard` 쓰면 예외 나도 자동 unlock
👉 그래서 **lock_guard 필수**

---

## 6️⃣ static / 전역 mutex 하나로 충분한지 생각

### 로그의 경우

```cpp
static std::mutex logMutex; // OK
```

### 데이터 구조 보호

* 객체마다 mutex 필요할 수도 있음

👉 **자원 단위로 mutex 설계**

---

## 7️⃣ 성능에 집착하지 말 것 (초반엔)

* mutex 비용 << 파일 IO 비용
* 로그는 디버깅용

👉 **안전성이 먼저**

---

## 8️⃣ 멀티스레드 아닌데 mutex 쓰는 건?

* 문제 없음
* 오버헤드 미미
* 미래 대비

---

## 9️⃣ 절대 하지 말 것 요약 ❌

| 금지                | 이유        |
| ----------------- | --------- |
| lock/unlock 직접 사용 | unlock 누락 |
| mutex 중첩          | 데드락       |
| 긴 작업 중 lock 유지    | 성능 저하     |
| 로그 안에서 로그         | 무한 대기     |

---

## 🔥 한 문장 요약 (면접용)

> “mutex는 RAII로 관리하고, 임계 영역을 최소화하며,
> 중첩 잠금과 재귀 호출을 피해야 합니다.”

---

이제 이 정도면
👉 **“mutex 왜 쓰고, 어떻게 쓰고, 언제 위험한지”**
전부 설명 가능해 👍

좋아, 이건 **운영체제에서 제일 많이 헷갈리는 개념쌍**이라
**정의 → 상태 → 예시 → 차이 한 방에** 정리해줄게.

---

## 1️⃣ Blocked(블락드) 상태

### ✅ 정의

> **태스크가 “조건이 충족될 때까지” 의도적으로 멈춘 상태**

* 자발적 대기
* OS가 관리
* 조건이 만족되면 **자동으로 Ready로 복귀**

### 🔒 Blocked가 되는 대표적 이유

* 뮤텍스 / 세마포어 대기
* 메시지 큐 수신 대기
* 이벤트/시그널 대기
* 타이머 대기 (`sleep`, `delay`)

### 📌 핵심 특징

* CPU ❌ 안 잡음
* 실행 가능성 ⭕ 있음
* 정상적인 시스템 동작

---

## 2️⃣ Deadlock(데드락)

### ❌ 정의

> **서로가 서로의 자원을 기다리며
> 영원히 진행할 수 없는 상태**

* 비정상 상태
* OS가 자동 복구 못 함 (대부분)
* 외부 개입 필요 (리셋, kill 등)

### 🔁 데드락의 전형적인 예

```
Task A: 자원 X 보유 → 자원 Y 대기
Task B: 자원 Y 보유 → 자원 X 대기
```

### 📌 핵심 특징

* CPU ❌ 안 잡음 (대개)
* 실행 가능성 ❌ 없음
* 기다려도 절대 풀리지 않음

---

## 3️⃣ 한눈에 비교 (이거 외우면 끝)

| 구분       | Blocked       | Deadlock    |
| -------- | ------------- | ----------- |
| 성격       | 정상 상태         | 오류 상태       |
| 대기 이유    | 자원/이벤트 조건 미충족 | 서로 자원 순환 대기 |
| 풀릴 수 있음? | ⭕ 있음          | ❌ 없음        |
| OS 개입    | 자동 관리         | 수동 개입 필요    |
| CPU 점유   | ❌             | ❌           |

---

## 4️⃣ “Blocked인데 Deadlock은 아닌” 대표 사례

### 뮤텍스 대기 (정상)

* L이 뮤텍스 사용 중
* H가 대기
* L이 실행되면 → 뮤텍스 해제
* H 실행

👉 **Blocked O / Deadlock X**

---

## 5️⃣ “Deadlock인 상태”

* A는 B가 풀어주길 기다림
* B는 A가 풀어주길 기다림
* 누구도 실행 못 함

👉 **Blocked O / Deadlock O**

---

## 6️⃣ 시험·면접용 한 문장

> **Blocked는 일시적 대기 상태이며 정상 동작의 일부이고,
> Deadlock은 태스크 간 순환 대기로 인해
> 영구적으로 진행이 불가능한 오류 상태이다.**

---

## 7️⃣ 핵심 정리 문장 (이거 기억해)

> **모든 Deadlock은 Blocked 상태이지만,
> 모든 Blocked가 Deadlock은 아니다.**

이제 이 개념 알면
👉 우선순위 역전
👉 뮤텍스 / 세마포어
👉 스케줄링 상태 질문

면접에서 거의 다 풀려 👍
