# 리눅스 디바이스 드라이버

## 임시 이름:
리눅스의 개발 요소
### 내용:
1. bootloader(u-boot)
2. device tree(overlay)
3. kernel(driver)
4. rootfilesystem(buildroot)

### 키워드:

---
## 임시 이름:
리눅스의 장점
### 요약:
리눅스는 **네트워크·성능·안정성·확장성·자율성**을 동시에 만족하는 OS이기 때문에 서버, 클라우드, 네트워크 장비, 임베디드까지 지배하고 있다.
### 키워드

---
## 임시 이름:
콘솔과 터미널
### 내용:
콘솔 : 물리 TTY
/dev/tty1
uart는 ttyS0를 쓴다
...
터미널 : 가상 TTY
/dev/pts/0
...
현재 터미널
/dev/tty
### 키워드

---
## 임시 이름:
리눅스의 실행환경
### 요약:
리눅스 포팅이란 특정 보드에 리눅스를 실행시키기 위해 각각의 하드웨어에 작업하는 일련의 과정을 일컫는다
### 내용:
1. CPU
    porting : X (manufacturer)
2. memory
    porting : 데이터시트를 참고, timing을 찾아서 커널에 맞춰줘야한다
3. console
    stdin, stdout, stderr
    일반적으로 구성이 되어 있지만 uart의 경우에는 필요할 수 있다
4. io (device/peripherals)
    장치 타입의 종류 마다 드라이버를 작성하는 방법이 다르다
    char  
    block 
    ...
    porting : driver 작성


---
## 임시 이름:
리눅스 커널 소스트리
### 내용:
주요 커널 소스
arch : 아키텍쳐 종속 코드
documentation : 커널 소스 문서
drivers : 디바이스 드라이버
include : 커널 헤더 파일들
init : 커널 부트와 초기화 관련
  - start_kernel : 커널이 시작할 때 최초로 실행되는 c 함수
ipc : 프로세스간 통신 코드
lib : 유틸리티 루틴


---
## 임시 이름:
드라이버 작성 시 고려 사항
### 요약:
실행영역 커널영역
  - 드라이버는 커널의 부분
  - 오작동 시 치명적 피해

콜백함수제공

커널기능이용
  - 메모리 할당
  - 인터럽트
  - 동기화

제작형태  결정
  - 커널형태
  - 모듈형태

---
## 임시 이름:
드라이버 소스 로케이션
### 한 줄 요약:

### 내용:
tree : kernel tree

in-tree
  /drivers/...
  커널 소스 트리 내에 hello.c
ex-tree
  /home/user/...

### 키워드:

### 질문:


---
## 임시 이름:
드라이버 제작 형태
### 요약:
dht11.c -> dht11.o ->
1. vmlinux : 커널 포함 형태
  - zImage에 내장
2. dht11.ko (*선호) : 커널 모듈에 탑재
  - kernel object
### 키워드:


---
## 임시 이름:
커널 소스
### 요약:
`/boot` 
1. kernel.org
2. linux-x.x.x.gz
  - kernel
    - vmlinux -> Image -> zImage (kernel8.img)
  - driverSource
    - `/lib/modules/6.1.21-v8+/kernel/drivers/`
  - divice tree
    - bcm2711-rpi-4-b.dtb
### 키워드:
start.elf : bootloader

---

## 임시 이름:
디바이스의 종류
### 요약:
문자 디바이스
- 바이트 단위 입출력
- /dev의 node를 통해 접근
    - /dev/console
    - /dev/ttyS0
- 주로 순차 참조
- keyboard, mouse, serial, modem, video,...

블록 디바이스
- 블록 단위 입출력 (버퍼 사용)
- /dev의 node를 통해 접근
    - /dev/sda
- 순차 및 랜덤 참조
- hard disk, cd-rom, usb disk,...

소스코드 위치
- drivers/char
- drivers/block
- drivers/misc
- drivers/input
- drivers/video
- drivers/i2c
- drivers/iio

### 키워드:

---

## 임시 이름:
유저 영역에서 커널 영역의 자료 참조
### 요약:
`/proc` : 커널이 오픈한 정보를 인터렉티브하게 열람하는 곳
- /cpuinfo : cpu의 정보
- /meminfo : 메모리 정보
- /proc : 커널의 명령행 인자
`/sys`  : 드라이버가 오픈한 정보를 인터렉티브하게 열람하는 곳
- /firmware
- bus
- device
- class

### 키워드:

---

## 임시 이름:
리눅스 커널 설치 및 빌드
### 요약:
upstream : 원본 저장소
[https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags]

fetch : 원격 저장소에서 소스 코드를 가져오는 단계
unpack : 압축된 소스를 해제하는 단계
patch : 소스 코드에 수정 사항을 적용
configure : 커널 빌드 옵션을 설정하는 단계
- `$ apt install libncurses-dev flex bison`
- `$ make menuconfig`
- `$ export KERNEL=kernel8`
- `$ export ARCH=arm64`
`.config`에 설정이 반영된다
makefile
- obj-$(CONFIG_DHT11) += dht11.o
    - obj-m -> xxx.ko
    - obj-y -> vmlinux -> zImage
    - obj-  -> no compile

compile
link
install
exec

### 키워드:

---

## 임시 이름:
리눅스 디바이스 트리 구조
### 요약:
1. source files
    - .dts     (.c)
    - .dtsi    (.h)
2. complier
    - dtc
3. binaries
    - .dtb     (device tree blob)
    - .dtbo    (dtb overlay)


### 키워드:

---

## 임시 이름:
모듈 빌드 설정 및 실행
### 요약:
`/lib/modules/???`

`$ insmod .ko` : 모듈 삽입
`$ lsmod`      : 현재 탑재 된 모듈
`$ rmmod`      : 모듈 삭제

`printk()`     : 기본적으로 콘솔에 출력
- `$ cat /var/log/messages`
`$ dmesg`      : 모듈 메세지 출력
- `-c`         : 출력 후 클리어

### 키워드:

---

## 임시 이름:
리눅스 포팅의 흐름
### 요약:
1. bootloader(u-boot, ...) : start.elf를 호출해서 시작
2. device tree(overlay) : .dtb 파일
3. kernel(driver) : 드라이버 패치
4. rootfile system(buildroot, yocto, ...) : 루트 파일 시스템을 구축


### 키워드:

---

## 임시 이름:
모듈의 기본 형태 `module.h`
### 요약:
초기화 등록 함수
초기화 해제 함수
등록 매크로 제공(`linux/init.h`)

module_platform_driver()
module_i2c_driver()
module_usb_driver()
module_spi_driver()
module_pci_driver()

모듈 라이선스가 반드시 필요
`MODULE_LICENSE("GPL")`
- 경고 메세지, 기능에 제약

### 키워드:

---

## 임시 이름:
모듈 드라이버 매개변수 전달
### 요약:
`$ insmod .ko param=arg`
- `charp`
- `module_param_array`

### 키워드:

---

## 임시 이름:
커널 심볼 내보내기
### 요약:
주어진 심볼을 전역으로 내보내 다른 드라이버에서도 사용하도록 함

```bash
cat /proc/kallsyms | grep expo_
ffffffec1f377020 r __kstrtab_expo_vars  [51_dev]
ffffffec1f37702a r __kstrtabns_expo_vars        [51_dev]
ffffffec1f37700c r __ksymtab_expo_vars  [51_dev]
ffffffec1f37702b r __kstrtab_expo_func  [51_dev]
ffffffec1f377035 r __kstrtabns_expo_func        [51_dev]
ffffffec1f377000 r __ksymtab_expo_func  [51_dev]
ffffffec1f37701c r __crc_expo_vars      [51_dev]
ffffffec1f377018 r __crc_expo_func      [51_dev]
ffffffec1f376000 T expo_func    [51_dev]
ffffffec1f378010 D expo_vars    [51_dev]
```

```bash
cat /lib/modules/6.1.21-v8+/modules.dep | grep dht11
kernel/drivers/iio/humidity/dht11.ko.xz: kernel/drivers/iio/industrialio.ko.xz
```
- 의존관계가 저장됨


### 키워드:

---

## 임시 이름:
캐릭터 디바이스의 특징
### 요약:
간헐적 데이터
바이트 데이터 발생

### 키워드:

---

## 임시 이름:
Charactor device / Block device 를 식별하는 방법
### 요약:
장치번호 
장치 번호의 타입
- dev_t @ linux/types.h
    - Major(12bit), Minor(20bits)
장치 번호의 구성
- Major 번호
    - 디바이스 드라이버를 실행시킬 때 디바이스를 찾아가기 위해 디바이스트리가 존재한다
- Minor 번호
    - 동종 장치의 개별 식별을 위해 사용되는 번호
장치 번호 구성용 매크로
- `MAJOR(dev_t dev)` : 주 번호 추출
- `MINOR(dev_t dev)` : 부 번호 추출
- `MKDEV(int major, int minor)` : 장치 번호 생성
등록 장치 번호 확인
`# cat /proc/devices`

장치 번호를 지정하는 방법
- Documentation/devices.txt 참조
- `# cat /proc/devices`로 현황파악
- 장치에 예약된 번호를 사용하거나 새로운 장치번호를 부여 (~ 254) or (255 ~ 512)
- `register_chrdev_region()` 를 이용하여 직접 지정
    - `int register_chrdev_region(dev_t first, unsigned int count, char *name)`

장치 번호를 할당하는 방법
- 비어있는 번호를 자동으로 할당
- 254번 부터 큰값부터 할당
- `alloc_chrdev_region()` 사용
    - `int alloc_chrdev_region(dev_t *dev, unsigned int firstminor, unsigned int count, char *name)`

장치 번호를 할당하는 방법
- `unregister_chrdev_region()` 사용
    - `void unregister_chrdev_region(dev_t first, unsigned int count)`

### 키워드:

---

## 임시 이름:
문자 장치 표현
### 요약:
`linux/cdev.h`
cdev 구조체를 사용하여 캐릭터 디바이스를 표현한다

`cdev_init()`
`void cdev_add(struct cdev *cdev, dev_t num, unsigned int count)`
`void cdev_del(struct cdev *cdev)`

### 키워드:

---

## 임시 이름:
장치 파일의 생성 방법
### 요약:
1. `# mknod /dev/name type major minor`
2. `int mknod(const char *pathname, mode_t mode, dev_t dev)`
3. `struct device *device_create()`

### 키워드:

---

## 임시 이름:
드라이버 컨텍스트
### 요약:
어떤 경로로 드라이버를 찾아왔는가

1. TOP(application) --> driver
- 프로세스 컨텍스트
- 시스템 콜에 의해 실행
    - 유저 영역에서 호출한 open에 해당하는 함수를 구조체를 통하여 드라이버에 구현해야 한다
        - .open      = my_open,
        - .release   = my_release
2. Bottom(hardware) --> driver
- 인터럽트 컨텍스트
- 인터럽트에 의해 실행


### 키워드:

---

## 임시 이름:

### 요약:

### 키워드:

---

## 임시 이름:

### 요약:

### 키워드:

---

## 임시 이름:

### 요약:

### 키워드:

---

## 임시 이름:

### 요약:

### 키워드:

---

## 임시 이름:

### 요약:

### 키워드:

---

## 임시 이름:

### 요약:

### 키워드:

---

## 임시 이름:

### 요약:

### 키워드:

---

## 임시 이름:

### 요약:

### 키워드:

---

## 임시 이름:

### 요약:

### 키워드:

---

## 임시 이름:

### 요약:

### 키워드:

---

## 임시 이름:

### 요약:

### 키워드:

---

## 임시 이름:

### 요약:

### 키워드:

---

## 임시 이름:

### 요약:

### 키워드:

---

## 임시 이름:

### 요약:

### 키워드:

---

## 임시 이름:

### 요약:

### 키워드:

---

## 임시 이름:

### 요약:

### 키워드:

---

## 임시 이름:

### 요약:

### 키워드:

---

## 임시 이름:

### 요약:

### 키워드:

---

## 임시 이름:

### 요약:

### 키워드:

---

## 임시 이름:

### 요약:

### 키워드:

---

## 임시 이름:

### 요약:

### 키워드:

---

## 임시 이름:

### 요약:

### 키워드:

---

## 임시 이름:

### 요약:

### 키워드:

---

## 임시 이름:

### 요약:

### 키워드:

---

## 임시 이름:

### 요약:

### 키워드:

---

## 임시 이름:

### 요약:

### 키워드:

---

## 임시 이름:

### 요약:

### 키워드:

---