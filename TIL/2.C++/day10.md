## 포인터와 메모리

- 정적 선언 변수 메모리 구조
    - 프로그램 실행 후 각 변수는 고유한 주소가 할당(확보)되고 값을 기록함
    - 변수 이름으로 메모리에 저장된 값을 사용함
- 메모리 주소가 실제 메모리 주소인가?
    - 메모리 주소는 메모리의 물리적 위치에 해당하는 고유 식별자지만 실제 위치는 런타임 중에 운영체제에 의해 위치가 변경될 수 있다. 따라서 메모리 주소는 실제 위치에 해당하는 가상 주소이다

### 포인터

- 메모리 주소를 저장하는 변수
- 64비트 운영체제 기준 8byte의 공간이 할당 된다
    - 32비트면 4byte인가
- 데이터 주소를 찾기 위해 데이터 형식 지정이 필요함
- 역참조자(*)(dereferencing)를 사용하여 참조 데이터에 접근

### 다중 포인터

- 포인터 또한 메모리 주소를 할당 받기 때문에 다른 포인터로 시작 메모리 주소를 저장할 수 있음
- 포인터의 포인터 = 다중 포인터(이중, 삼중…)

### 배열과 포인터

- 배열 : 동일한 메모리 구조의 변수 여러개를 하나로 묶어 선언하는 방법
- 배열이름[인덱스]로 개별 변수의 값을 읽기/쓰기, 인덱스는 배열 위치 지정
- &arr[1] == arr+1

### 동적 메모리 할당

- 프로그램 실행 중 필요한 크기의 메모리를 OS에 요청하여 사용
    - new
        - int* arr = new int[10];
    - delete
        - delete[] arr;
        - 배열 해제할 때 첫번 째 값만 반환하는것 주의
- 정적 할당 : 스택 메모리 영역에 할당, 함수 종료 시 자동으로 소멸
    - 할당 가능한 영역이 적고 이를 초과시 OS가 강제 종료하기도 함
- 동적 할당 : 힙 메모리 영역에 할당, 함수 종료 등과 무관하게 유지
    - 할당 가능한 영역이 크고 개발자가 직접 관리
- 함수에서 포인터 변수 선언, 메모리를 할당하고 해제 없이 함수 종료 시 메모리 누수 발생
    - 메모리 누수는 누적이 되고 사용가능 힙 영역이 줄어듬
- 초기화
    - int* p = nullptr
    - pt = new int[10]
- 주의점
    - 유효한 메모리만 역참조 하기
        - 포인터 선언 후 유효힌 메모리만 참조 해야함
        - 메모리 할당 후 해제되지 않은 메모리만을 역참조 해야함
        - 메모리 해제 후 pullptr을 대입해 유효하지 않은 메모리를 참조하지 않아야 함
    - 메모리 범위 정확히 확인하기
        - 배열의 인덱스가 전체 범위를 벗어나는 문제와 동일
        - 포인터 변수에는 메모리 크기 정보가 없어 더욱 주의
    - 댕글링 포인터(dangling pointer)
        - 유효하지 않은 메모리를 참조
        - 역참조 하거나 값을 대입하면 세그먼트 오류, 예상치 못한 변수의 값 변경 등 오류가 발생할 수 있음

## 정적 변수와 상수 변수

- 지역 변수 vs 전역 변수
    - 지역 변수(local variable): 함수 또는 반복 구문 내부에 선언과 동시에 생성, 해당 블록 내에서만 효력
    - 전역 변수(gloabal variable): 전역 범위에 선언된 변수로, 해당 파일 전체에서 효력
        - 프로그램을 구성하는 전체 파일에서 사용하기 위해서는 별도 선언 문법이 필요함
- 자동 지속
    - 지역 변수가 선언된 {}로 둘러 쌓인 블록을 벗어나면 소멸되는 것을 자동 지속이라고 함
- 정적 지속
    - 지역 변수에 static 키워드를 사용하면 전역에서 사용할 수 있는 정적 지속으로 변경
    - 변수 선언 시 생성되는 것이 아닌 프로그램이 시작되면 생성되고 프로그램이 종료되면 소멸됨
- 정적 변수 선언
    - static 키워드를 변수 선언 앞에 사용시 정적 변수가 선언됨
- static
- const
    - const int* ptr = &a; // 가리키는 값이 상수가 됨
    - int* const ptr = &a; // ??

## 레퍼런스 변수

- 선언
    - &ref = a;
- 포인터와 같은 용도로 사용하지만 포인터와 달리 주소 저장 공간도 할당되지 않음
    - 참조할 원본 변수로 무조건 초기화 해줘야한다
- 참조 대상을 변경하려고 하면 초기화 대상의 값이 변경이 됨
- 기본적으로 상수를 참조할 수 없다
    - 상수 리터럴 또는 상수 변수는 읽기만 가능하기 때문에 참조할 수 없음
    - 대신 const로 선언하면 참조할 수 있음

## 표현식과 구문의 차이

- 표현식 : 하나 이상의 변수, 연산자, 리터럴을 조합해 값을 평가하고 결과를 반환
    - 수학에서 계산을 수행하는 수식과 같으며 결괏값이 항상 나오는 코드
- 구문 : 하나 이상의 연산, 동작을 실행하는 명령문의 집합, 값을 할당하거나 실행 흐름을 제어
    - 여러 표현식을 포함할 수 있으며 보통 쌍반점(;)으로 끝남
    - 컴파일러가 이해하고 실행할 수 있는 최소의 독립적인 코드 조각
    - 코드 한 줄부터 여러 줄의 블록까지 구문으로 볼 수 있음. 한 개 이상의 표현식과 키워드를 포함

## 예외 처리 구문

### try, catch, throw

- 예외가 발생했을 때 프로그램의 제어 흐름을 변경하고 예외를 처리
    - try: 예외가 발생할 수 있는 코드 불록을 중괄호{}로 감싸 준다
    - throw: 예외를 catch 블록으로 던진다
    - catch: throw로 던진 예외를 받아서 처리한다
        - catch(…) : if문의 else 처럼 명시하지 않은 나머지 예외 처리

### assertion

- assert(조건) : 조건에 해당하지 않으면 예외 발생
- 어설션 : 코드를 검증하여 예상치 못한 상황에서 프로그램 동작을 중단
    - 예상치 못한 상황, 결괏값으로 인한 심각한 오동작 대신 프로그램을 중단
    - <cassert> 헤더에 정의된 assert 매크로를 통해 사용, assert는 디버그 모드에서 사용할 수 있는 매크로 함수
- 디버그 모드와 릴리즈 모드
    - 디버그 모드 : 컴파일할 때 디버깅을 위한 정보들을 삽입, 문제 원인을 수월하게 찾을 수 있음
    - 릴리즈 모드 : 사용자에게 배포되는 코드를 만들 때 사용. 디버깅 정보, 심벌, 주석 등이 제거되고 최적화 됨
- assert를 사용할 때 주의할 점
    - 디버그 모드에서만 동작하므로 프로그램에 영향을 미치는 코드는 사용하지 말아야 함
        - 릴리즈 모드로 컴파일 할 경우 해당 코드가 동작하지 않음

### noexcpt / set_terminate

- 

## 객체지향 프로그래밍

### 객체 끼리의 관계

- has-a releationship
- is-a releationship
- use-a releationship

---

## 자습

- fault, error, exception
- 업캐스팅 / 다운캐스팅
- assert와 tdd의 관계
-