# 1일차
## 리눅스 프로그래밍

kernel < shell(bash) < user
장치드라이버는 커널의 일부분
리눅스는 모든걸 파일로 관리한다
cpu : --> program
program
	1. a.out @ hdd	- passive process		// 실행 중이지 않은 프로세스
	2. a.out @ RAM	- active process		// 실행 중인 프로세스
cpu의 자원은 프로세스가 사용
cpu의 자원을 어느 프로세스에 할당할건지 정하는게 스케줄링 그걸 하는 주체가 스케줄러
스케줄링 알고리즘은 여러 개가 있고 OS마다 다름
여러 프로세스를 동시에 실행하면 멀티 태스킹
인터럽트 : 하드웨어가 소프트웨어에 보내는 신호

## 1장
## 2장
설치

## 3. 터미널과 셸
### 터미널
- 컴퓨터가 사용자와 상호작용할 수 있는 하드웨어
### 셸
- 운영체제와 사용자와 상호작용할 수 있는 소프트웨어

- 운영체제가 제공하는 명령어 기반 인터페이스

### 셸 스크립트
- 셸에서 동작 가능한 명령을 모아놓은 파일
- .sh
- 한 번에 여러 명령을 수행
```bash
$ echo echo hello world >> hello.sh
$ . hello.sh
$ hello world
```

### 리눅스 기본 명령어
- man [옵션] [섹션] 페이지
- ls : 파일 목록 확인
    - -a : 숨김 파일 확인
    - -l : 상세 내용 확인
    - -i : 
- cd
    - change dir
- pwd
    - print working dir
    - 현재 절대 경로 표시
- cat
    - concatenate
    - 파일의 내용을 연결하거나 조회하는 명령어


- set
- grep
- wc
    - word count
- | 키워드

- mkdir
    - -p
- rmdir
    - 비어있는 디렉토리 삭제
- mv
    - 파일 위치를 변경
    - mv 원본 복사본 : 이름 변경
- rm
    - -r
    - -f
- cp

- mount

- w
- stat


## 파일 시스템
리눅스의 파일시스템은 **하나의 트리 구조**로 시작하며 최상단은 `/`(root)입니다. 모든 파일·디바이스·네트워크까지 **파일처럼 보이도록** 설계되어 있습니다. 아래는 핵심 디렉토리의 역할입니다.

---

## 🗂️ 전체 구조 개요

### `/` — Root 디렉토리

시스템의 모든 경로가 여기서부터 출발합니다.
하드디스크, USB, 네트워크 공유까지도 `/mnt`, `/media` 등을 통해 여기에 연결됩니다.

---

## 핵심 시스템 디렉토리

### `/bin` — 기본 실행 파일

* 모든 사용자가 사용할 **필수 명령어** (`ls`, `cp`, `mv`, `cat`, `grep` 등)
* 부팅·단일 사용자 모드에서도 필요한 최소 명령 포함

### `/sbin` — 시스템 관리 실행 파일

* 관리자(root)용 핵심 도구 (`fsck`, `mount`, `iptables`, `reboot`)
* OS 유지/복구에 필요한 실행파일

### `/usr` — 사용자 공간 프로그램

* 가장 많은 프로그램과 라이브러리 존재
* `/usr/bin`, `/usr/sbin`, `/usr/lib` 등
* 멀티유저 시스템에서 “Universal Shared”(공유 가능한 영역)

> ⚠️ `/usr`는 “user home”이 아닙니다. 사용자 계정은 `/home`에 생성됩니다.

---

## 시스템 운영 관련

### `/etc` — 설정 파일

* 시스템 전체 설정
* 네트워크 설정, 데몬 설정, 서비스 설정 등
* 예: `/etc/passwd`, `/etc/ssh/ssh_config`

### `/lib`, `/lib64` — 시스템 라이브러리

* `/bin`, `/sbin` 실행파일이 의존하는 중요 라이브러리
* 커널 모듈 `/lib/modules`

### `/boot`

* 커널 이미지(`vmlinuz`)
* initramfs
* 부트로더(예: GRUB) 구성 파일

---

## 사용자 관련

### `/home`

* 일반 사용자 계정 디렉토리
* `~` = `/home/<username>`
* 개인 설정, 문서, 개발 프로젝트 저장

### `/root`

* root 사용자 전용 홈
* `/home`과 별도 유지하는 것이 보안상 일반적

---

## 하드웨어와 시스템

### `/dev` — 디바이스 파일

* 모든 하드웨어를 파일처럼 표현
* `/dev/sda` (디스크), `/dev/tty` (터미널), `/dev/null`
* 커널이 udev 등을 통해 동적으로 생성

### `/proc`, `/sys` — 가상 파일시스템

* **실제 파일 아님**, 메모리에 존재
* `/proc` → 프로세스·CPU·메모리 상태

  * 예: `/proc/cpuinfo`, `/proc/meminfo`
* `/sys` → 커널·장치·드라이버 구조 노출

---

## 마운트와 임시 파일

### `/mnt`, `/media`

* 외부 저장장치 마운트 지점
* `/media/usb`, `/media/cdrom` 등

### `/tmp`

* 임시 파일 저장
* 부팅 시 초기화되는 경우 많음

---

# 📘 FHS (Filesystem Hierarchy Standard)

리눅스 배포판이 **대체로** 따르는 구조 표준.
예: `/bin`이 시스템 핵심 명령어, `/usr/bin`이 일반 프로그램.

---

## 빠른 정리

* **핵심 실행 →** `/bin`, `/sbin`
* **설정 →** `/etc`
* **일반 프로그램 →** `/usr`
* **사용자 데이터 →** `/home`
* **커널/부팅 →** `/boot`
* **디바이스 →** `/dev`
* **커널 상태 →** `/proc`, `/sys`

---

원하시면 **각 디렉토리 실제 예시**(Ubuntu, CentOS 등)나 **임베디드 Linux(rootfs 구성)** 관점에서 더 깊게 정리해 드릴게요.

### 리눅스 시스템 구성 요소
1. bootloader(u-boot)
2. kernel
3. device tree
4. root file system
#### Root file System
mount ?
#### 가상파일시스템

### 리눅스 파일 시스템

ext4
vfat

### 파일의 종류
- 일반 파일 : -
- 디렉터리 : d
- 심볼릭 링크 파일 : l
- 블록 디바이스 파일 : b
- 문자 디바이스 파일 : c
- 파이프 파일 : p
- 소켓 파일 : s
### 디렉토리
#### 루트 디렉터리 하위 주요 디렉터리
/bin
- 기본 실행 명령어
/dev
- 디바이스 파일
/etc
- 시스템 설정 파일
/home
- 사용자 홈 디렉터리
/lib
- 시스템 라이브러리
/mnt
- 시스템에 디스크 등을 임시로 마운트할때 사용
/proc
- porcfs가 마운트
- 커널이 정보를 오픈해놓는곳
/root
- 루트 사용자의 홈 디렉터리
/sbin
- 시스템 관리용 명령어
/sys
- sysfs가 마운트
- 디바이스 드라이버들이 정보를 오픈
/tmp
- 시스템 임시 파일
/usr
- 시스템 소프트웨어

### 소프트링크와 하드링크
- ln
    - 하드 링크

```bash
$ls -l
-rw-rw-r-- 2 ottl ottl 18 11월 26 16:09 a
-rw-rw-r-- 1 ottl ottl  6 11월 26 16:04 ac
-rw-rw-r-- 2 ottl ottl 18 11월 26 16:09 al
```

```bash
$stat a
  File: a
  Size: 18              Blocks: 8          IO Block: 4096   regular file
Device: 805h/2053d      Inode: 1572877     Links: 2
Access: (0664/-rw-rw-r--)  Uid: ( 1000/    ottl)   Gid: ( 1000/    ottl)
Access: 2025-11-26 16:09:18.124124032 +0900
Modify: 2025-11-26 16:09:12.312094124 +0900
Change: 2025-11-26 16:09:12.312094124 +0900
 Birth: -
```
- 메타데이터 확인

- ln -s
    - 소프트 링크
```bash
$ls -l
total 16
-rw-rw-r-- 2 ottl ottl 18 11월 26 16:09 a
-rw-rw-r-- 1 ottl ottl  6 11월 26 16:04 ac
-rw-rw-r-- 2 ottl ottl 18 11월 26 16:09 al
lrwxrwxrwx 1 ottl ottl  1 11월 26 16:14 as -> a
-rw-rw-r-- 1 ottl ottl 74 11월 26 14:44 hello.c
```

디렉토리에다 링크를 걸수있는건 symbolic link(soft link)만 가능


소프트링크 하드링크

대상 파일의 확인

대상 파일의 범위

대상 파일과 링크 파일의 결합도



#### inode
- 실제 파일의 정체(이름?)







---

### memo
- mcu와 pc용 프로세스의 차이
    - mcu는 직렬 pc는 병렬?
- 하이퍼바이저 의미
- 


# 2일차
## 5. 사용자와 사용자 그룹
### 사용자
#### 사용자의 종류
- root 사용자 : 리눅스 시스템의 모든 권한을 가진 관리자 계정
- 시스템 사용자 : 리눅스 시스템에서 만든 사용자
- 일반 사용자 : root사용자와 시스템 사용자를 제외한 모든 사용자

#### root 사용자
- 권고 사항
1. root 사용자의 비밀번호를 복잡하게 설정하고 주기적으로 변경하라
2. 시스템 외부에서 root 사용자로 로그인하지 못하게 설정하라

#### su 명령어


```bash
cat /etc/password
ottl:x:1000:1000:ottl,,,:/home/ottl:/bin/bash
```
- 의미


#### 사용자 그룹
```bash
cat /etc/group
ottl:x:1000:
```

#### 사용자 추가 및 삭제하기
```bash
adduser
deluser
```

## 6. 소유권과 권한
### 소유권
```bash
-rw-rw-r-- 1 ottl ottl 0 11월 27 10:05 1
-rw-rw-r-- 1 ottl ottl 0 11월 27 10:05 2
-rw-rw-r-- 1 ottl ottl 0 11월 27 10:05 3 # type/User/Group/Others

iam@ottl-VirtualBox:~$ echo hello >> 1
bash: 1: Permission denied
```

```bash
chown -r
```
### 파일 권한
chmod 
r: 4
w: 2
x: 1


### 디렉토리 권한
r: 폴더 내용 확인
w: 폴더 내 파일 생성
x: 폴더 열기

- .
- source

## 7. 프로세스 관리
### 프로세스란
- linux is process oriented
    - 스케줄링 엔티티
        - process : {user process}
        - thread  : {user pthread / kenal kthread}

    - "task_struct" : task(process) control bock
        - 프로세스 상태를 관리하기 위한 구조체
        - PCB(Process Controll Block)

    - instance(windows)


- active process 
- passive process



- $ps
    - -l
    - -e : entire
    - -f
- $pstree

```bash
$ ps -elf | head
F S UID          PID    PPID  C PRI  NI ADDR SZ WCHAN  STIME TTY          TIME CMD
4 S root           1       0  0  80   0 - 42394 -      08:57 ?        00:00:22 /sbin/init splash
1 S root           2       0  0  80   0 -     0 -      08:57 ?        00:00:00 [kthreadd]
1 I root           3       2  0  60 -20 -     0 -      08:57 ?        00:00:00 [rcu_gp]
1 I root           4       2  0  60 -20 -     0 -      08:57 ?        00:00:00 [rcu_par_gp]
1 I root           5       2  0  60 -20 -     0 -      08:57 ?        00:00:00 [slub_flushwq]
1 I root           6       2  0  60 -20 -     0 -      08:57 ?        00:00:00 [netns]
1 I root           8       2  0  60 -20 -     0 -      08:57 ?        00:00:00 [kworker/0:0H-events_highpri]
1 I root          10       2  0  60 -20 -     0 -      08:57 ?        00:00:00 [mm_percpu_wq]
1 S root          11       2  0  80   0 -     0 -      08:57 ?        00:00:00 [rcu_tasks_rude_]
```

- [] = 커널 쓰레드
- PID 1 : systemd : sbin/init splash
    - 부팅할 때 초기화를 담당
    - SysV init를 업그레이드 한 버전
- PID 2 : [kthreadd]


```bash
ottl@ottl-VirtualBox:~$ ps -l

F S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
0 S  1000  115160  115159  0  80   0 -  3019 do_wai pts/0    00:00:00 bash
0 R  1000  115736  115160  0  80   0 -  3179 -      pts/0    00:00:00 ps
```
- S : 상태
- PID : process ID
- PID : Parents process ID
- PRI & NI : 우선순위

- $ sleep 100

- $ kill -l
    - $ kill -3 {PID}

### 프로세스의 생애주기
1. fork();

### 프로세스 스케줄링

### 프로세스의 상태
실행 또는 대기
중단
깨어나지 않는 수면 상태
깨어날 수 있는 수면 상태
종료


### 파일 디스크립터와 표준 스트림
파일 입출력의 종류
    1. 저수준 파일 입출력
        - 버퍼 x : for device
        - 버퍼 o : for application
    2. 고수준 파일 입출력
        - 버퍼 o : for application

#### file descriptor
```c
    int fd = open(); // read(), write(), close()
    printf("%d", fd); // 3 ...4...5 ~
```
stdin  0
stdout 1
sdderr 2
이미 3가지의 파일이 open되어 있음

#### file stream
```c
    FILE* fp = fopen(); // fread(), fwirte(), ..., fclose()
```

### Foreground와 Background 프로세스
- $ jobs
- $ fg {jos number *ex %3*}

#### fg
stdin 가능
stdout 가능
stderr 가능

#### bg
stdin 불가
stdout 가능
stderr 가능

#### $ ping
ICMP 에코 요청 및 응답

#### $ jobs
- 실행중인 유저 프로세스?

### IPC
- Inter Process Communication : 프로세스 간 통신에 사용하는 도구

#### 파이프
- 단방향

- pipe : 두 프로세스 간 데이터를 전송할 때 사용하는 IPC
- named pipe : 파일 형식의 이름을 부여할 수 있는 파이프
#### 메시지 큐
- 단방향

#### 소켓
- 양방향?

- 소켓 : 
- 인터넷 소켓 : 
- 유닉스 도메인 소켓

#### 공유 메모리
각자의 가상메모리로 동일한 물리 메모리에 접근하여 통신하는 방식?

#### 세마포어
- 카운팅 세마포어
- 바이너리 세마포어


## 8. 시그널 송수신
- 특정 프로세스에게 어떤 이벤트가 발생했음을 알려줌
```bash
$ kill -l;
 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP
 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1
11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM
16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP
21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ
26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR
31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3
38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12
53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7
58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
63) SIGRTMAX-1  64) SIGRTMAX
```

커널 -> 프로세스
프로세스 <-> 프로세스
프로세스 자신

에게 송신할 수 있다


POSIX



# 리눅스 활용

## 9. Bash: 조건문과 테스트 연산자
### 변수 in Bash
```bash
$ V1 = test
$ echo $V1
test
```

let "표현식"
expr 표현식



### 조건문과 테스트 연산자
#### if문
if
then
elif
then
else
fi

if()와 if(( a < b ))


#### if문의 조건
- True  : 프로세스 종료 코드로 0을 리턴 받았을 때
- False : 0이 아닌 값을 받을 때

#### 문자열 테스트 연산자

#### 산술 테스트 연산자

#### 파일 테스트 연산자

#### 논리 테스트 연산자

#### case문


## 10. Bash: 반복문, 함수, 변수, 배열, 쿼팅

### 반복문

#### for문
```bash
// 기본 형식
for 변수 in 목록
do
    명령
done

// C언어 스타일
for((초기식; 조건식; 증감식))
do
    명령
done
```

#### while문
- 조건이 참인 동안 반복
```bash
while 조건식
do
    명령
done
```

#### until문
- 조건이 거짓인 동안 반복
```bash
until 조건식
do
    명령
done
```

#### break와 continue
- break : 반복을 중단
- continue : 다음 반복으로 건너뜀

### 함수

#### 함수 작성

#### 함수의 반환값과 출력값
- 반환값 : 
    
- 출력값

- 명령어 치환


### 변수 심화

#### 매개변수
- 위치 매개변수

- 특수 매개변수
    - $# : 매개변수의 갯수
    - $0 : 실행중인 스크립트 파일의 이름
    - $* : 모든 위치 매개변수를 하나의 열로 인식 - 개별 접근시 하나로 인식
    - $@ : 모든 위치 매개변수를 하나의 열로 인식 - 개별 접근시 개별로 인식
    - $? : 최근에 실행된 명령이나 함수, 스크립트의 프로세스 종료 코드 또는 반환값
    - $$ : 현재 실행중인 셸의 PID

#### 변수의 범위
- 변수에 접근해 사용할 수 있는 코드 영역 또는 코드 영역의 범위

- 함수 로컬 변수: 함수안에서 로컬이라는 키워드와 함께 선언된 변수
- 글로벌 변수: 함수로컬변수를 제외한 모든 변수

- 쉘 변수
-    set

- 환경 변수
    - env
    - $ export
        - 쉘에서 선언한 변수를 새로운 스크립트에서도 사용할 수 있게 함
    - 주요 환경 변수
    - HOME
    - PATH
        ```bash
        /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/
        local/games:/snap/bin
        ```
        - 명령어를 찾는 위치
    - PWD
    - USER
    - SHELL
    - LANG
    - TERM
    - PS1
    - HOSTNAME



- .profile
- .bashrc

### 쿼팅

- single ' ' : 문자 그대로 출력
- double " " : 변수, 탈출문 등을 반영시키고 출력
- escape \




## 리디렉션과 파이프라인

### 리디렉션
#### 출력 리디렉션
```bash
>
>>
```
- > : write
- >> : append

- 표준 에러 리디렉션

#### 입력 리디렉션


#### here documents
#### here strings


### 파이프라인










---

# memo
- !$

- () (()) [] [[]] 차이
---

# ✅ 조건식

## `[` … `]`  또는  `[[` … `]]`

조건 판단용(참/거짓)

```bash
if [ "$a" -gt 3 ]; then
    echo "bigger"
fi
```

```bash
if [[ $str == foo* ]]; then
    echo "starts with foo"
fi
```

* `[ ]` = POSIX test → 엄격, 공백 중요
* `[[ ]]` = Bash 확장 → 안전하고 기능 많음

---

# ✅ 산술식

## `(( ))`

**정수 연산 + 대입 + 조건**

```bash
((x = 3 + 5))
((x++))
if ((x > 10)); then echo hi; fi
```

* `$` 없이 변수 직접 변경 가능
* 결과는 **참/거짓**으로도 사용됨

---

# ❗ `$(( ))` — 계산 결과를 **값으로 반환**

출력용 또는 대입에 사용

```bash
sum=$((3 + 5))
echo $((x * 10))
```

* `(( ))`과 다르게 “값을 문자열로 반환”함

---

# 📌 완벽 정리

| 구문       | 의미      | 용도                |
| -------- | ------- | ----------------- |
| `[ ]`    | test 명령 | 조건 비교 (POSIX)     |
| `[[ ]]`  | 확장 test | 조건 비교 (문자열/패턴/안전) |
| `(( ))`  | 산술 평가   | 정수 연산·대입·조건       |
| `$(( ))` | 산술 확장   | 정수 계산 결과 반환       |

---

## 한 줄 요약

> 조건 판단은 `[ ]` / `[[ ]]`,
> 숫자 계산은 `(( ))` 또는 `$(( ))`.

- 환경변수
---

# 🔥 1) **환경 변수(PATH, LANG 등) → `.profile`**

이유:

* **로그인 시 1번만 실행**
* **자식 프로세스 전체가 공유해야 하는 값**에 적합

예:

```bash
export PATH="$HOME/bin:$PATH"
export JAVA_HOME="/usr/lib/jvm/java-17"
```

---

# 🔥 2) **개발 편의 / 셸 기능(alias, 함수) → `.bashrc`**

이유:

* **새 터미널 열 때마다 실행**
* 인터랙티브 셸 환경 개선 목적

예:

```bash
alias ll='ls -alF'
export PS1="\u@\h:\w$ "
```

---

# 🔥 “export한 걸 저장” 관점에서 요약

* **단순히 export 명령만 입력** → 현재 세션에만 반영 = 터미널 닫으면 사라짐
* **설정 파일에 적어두면** → 다음 로그인/터미널부터 자동 적용

---

# 💡 어디에 넣을지 빠른 판단

| 성격                  | 파일                                          |
| ------------------- | ------------------------------------------- |
| 시스템 전체/환경변수         | `.profile`, `.bash_profile`, `/etc/profile` |
| 사용자 편의/alias/prompt | `.bashrc`                                   |
| GUI 로그인 전역 변수       | `~/.profile` 또는 `/etc/environment`          |

---

# ✔️ 실전 예시

👉 PATH 유지하고 싶다

### ❌ 그냥 터미널에서

```bash
export PATH=$HOME/bin:$PATH
```

→ 세션 종료 시 날아감

### ✔️ 영구 적용

**`~/.profile`** 또는 `~/.bash_profile`에 추가

```bash
export PATH="$HOME/bin:$PATH"
```

---

# 🤔 왜 `.profile` vs `.bashrc`가 나뉨?

* 환경 변수는 **로그인 시 한 번**만 설정하면 충분
* alias/프롬프트는 **매 인터랙티브 세션마다** 적용되면 편함

그래서:

> **환경 = profile, 편의 = bashrc**

---

## 📌 결론

**export 값 영구 적용하려면 설정 파일에 저장해야 한다.**

* **환경 변수 → `.profile` 권장**
* **alias, prompt → `.bashrc`**



# 4일차

## 11. 확장과 쉘 옵션

### 확장
- 셸이 명렁을 해석하고 실행하기 전에 명령에 포함된 문자열, 수, 와일드카드 패턴 등을 변환하는 과정

() : parenthesis
[] : bracket
<> : angle bracket, chevrons
{} : curly brace
'' : single quote
"" : double quote
`` : grave accent
~ : tilde

#### brace expansion
- {} 를 사용해 문자열 시퀀스나 조합을 생성하는 것
```bash
echo {1..5} # 1부터 5까지 변환
1 2 3 4 5
echo {A..Z..2} # A부터 Z까지 증분 2
A C E G I K M O Q S U W Y
```

#### tilde expansion
- ~가 홈 디렉토리로 변환되는 것

#### 명령어 치환
- $()로 둘러싸인 명령어를 실행하고, 그 결과를 현재 셸의 명령어나 스크립트에서 사용할 수 있게 하는 것
```bash
#func_com_sub.sh
function magic_box_with_progress()
{
        input="$1"
        let "result = input + 8"
        echo "$input + 8 = $result"
        return $result
}

progress=$(magic_box_with_progress "7")
result=$?

echo "progress: $progress" # 표준 출력이 저장 된다
echo "result is $result"

#bash
$ ./func_com_sub.sh 
progress: 7 + 8 = 15
result is 15

```
```bash
~$ echo "current time is $(date +"%Y-%m-%d %H:%M:%S")" # 띄어쓰기 주의
current time is 2025-12-01 10:13:33
```

#### 산술 확장
- $(())나 이중괄호 (())로 감싼 표현식을 산술 연산해 그 결과를 스크립트에서 사용할 수 있게 하는것
- 정수형 변수의 산술 연산
    - declare -i로 변수 선언
- 산술 연산자
    - +, -, *, /, %, ++, -- : C언어와 동일
    - ** : 제곱, 2**2(=2²)
- 비교, 논리, 비트, 대입 연산자
    - C언어와 동일
 
 #### 서브스트링 확장
 - 변수에 저장된 문자열의 특정 부분을 추출하는 기능

 ```bash
# ${변수:오프셋:길이}
$ string="hello world!"
$ echo ${string: 1} # 앞에서 시작해 1부터 출력
ello world!
$ echo ${string: 1: 3} # 앞에서 시작해 1부터 3까지 출력
ell
$ echo ${string: -5} # 뒤에서 시작해 5부터 출력
orld!
$ echo ${string: -5: 3} # 뒤에서 시작해 5부터 3까지 출력
orl
 ```

#### 문자열 변경
```bash
# ${변수/패턴/문자열}
$ music="mi re do re mi mi mi"
$ echo ${music/mi/Mi} # 처음으로 발견되는 mi를 Mi로 변경
Mi re do re mi mi mi
$ echo ${music//mi/Mi} # 발견된 모든 mi를 Mi로 변경
Mi re do re Mi Mi Mi
$ echo ${music/#mi/MI~} # 해당 패턴으로 시작될 때만 변경
mi re do re mi mi mi
$ echo ${music/%mi/MI~} # 해당 패턴으로 끝날 때만 변경
mi re do re mi mi MI~

```
#### 대소문자 바꾸기

#### 변수 값에 따른 확장
- 빈 값일 때 지정한 값 사용하기
```bash
$ ${변수:-문자열}
```

- 빈 값일 때 지정한 값 사용하고 저장하기
```bash
$ ${변수:=문자열}
```

- 빈 값일 때 지정한 값 사용하고 저장하기
```bash
$ ${변수:?문자열}
```

- 빈 값이 아닐 때 지정한 사용하기
```bash
$ ${변수:+문자열}
```

#### 간접 확장
```bash
$ ${!변수}
```

#### 일치하는 패턴 제거

#### 확장 연산자

### 쉘 옵션


## 13. 시스템 관리
### 패키지와 패키지 관리 시스템
패키지 : 소프트웨어 프로그램과 관련 파일들을 포함한 묶음
패키지 관리 시스템 : 패키지의 설치 업데이트 구성 제거를 자동화하고 관리하는 시스템

### systemd
user space
service > system-V init

systemctl
책 확인

staus
start
stop
restart

#### 데몬 프로세스

#### 유닛 파일
유닛파일을 만드는 방법

### .bashrc를 이용한 개인화

#### .profile과 .bashrc
.profile은 로그인을 하면 실행되는 설정파일
.bashrc는 프롬프트가 하나 생성되면서 실행됨

.profile을 실행하면 .bashrc가 실행된다


#### .bashrc의 역할
- 다른 파일을 읽어들인다
- 변수를 설정한다
- alias를 설정한다
- bash 셸 옵션을 설정한다
- 편의를 위한 개인 설정 모음 파일


```bash
$ alias [설정] # alias 목록 생성, 열람
```

## 14. 필수 커맨드라인 툴

### 1) grep
- Global Regular Expression Print
- 표준 입력이나 텍스트 파일에서 특정 패턴이나 문자열을 검색하는 커맨드라인 툴
```bash
$ grep [옵션] 패턴 [파일]

$ cat [파일] | grep [옵션] 검색어 # 파이프라인과 결합하여 사용
```

#### 옵션 목록

| 옵션     | 의미                  | 예시               |                   
| ------ | ------------------- | ------------------------------------- |
| `-r`   | 디렉토리 **재귀 검색**      | `grep -r "main" src/` |                   
| `-i`   | **대/소문자 무시**        | `grep -i "error" log.txt`       |
| `-v`   | **매칭 제외**           | `grep -v "DEBUG" server.log`|
| `-n`   | **줄 번호 출력**         | `grep -n "TODO" *.c`                  | 
| `-c`   | **매칭된 라인 개수**       | `grep -c "ERROR" access.log`          | 
| `-l`   | **매칭된 파일명만**        | `grep -l "main" *.c`           |    
| `-L`   | **매칭되지 않은 파일명만**    | `grep -L "TODO" *.c`|    
| `-E`   | **확장 정규표현식 사용**     | `grep -E "ERROR WARN" system.log` |
| `-o`   | **매칭된 부분만 출력**      | `echo "v1.2.3" \| grep -o "[0-9.]\+"` | 
| `-A N` | **매칭된 라인 이후 N줄 표시** | `grep -A 3 "panic" kernel.log`        | 


### 2) find
- 파일이나 디렉터리를 검색하는 커맨드라인 툴
```bash
$ find [옵션] [경로] [표현식]
```
- $ find -L : 심볼릭 링크를 쫓아가 링크에 해당하는 파일들에 대해 작업
- P find -P : 심볼릭 링크 자체에 대해 작업 (default)

#### 주요 표현식
| 표현식           | 의미                | 예시                                             |
| ------------- | ----------------- | ---------------------------------------------- |
| `-name`       | 파일명 패턴 매칭 (와일드카드) | `find . -name "*.c"` |
| `-iname`      | 대소문자 무시 파일명 매칭   | `find . -iname "*.png"`|
| `-type`       | 파일 타입 조건| `find . -type f` (파일)|
| `-size`       | 파일 크기 조건          | `find . -size +10M`        |
| `-mtime`      | 수정 시간 (일 단위)      | `find . -mtime -3` (최근 3일)     |
| `-mmin`       | 수정 시간 (분 단위)      | `find . -mmin -60` (지난 1시간) |
| `-user`       | 특정 사용자 소유  | `find /var -user root`         |
| `-group`      | 특정 그룹 소유   | `find /data -group dev`       |
| `-perm`       | 퍼미션 조건             | `find . -perm 644`    |
| `-exec`       | 찾은 결과에 명령 실행 | `find . -name "*.log" -exec rm {} \;`    |
| `-maxdepth`   | 검색할 디렉터리의 최대 깊이 | `find . -maxdepth 1 \;`    |
| `-mindepth`   | 검색할 디렉터리의 최소 깊이 | `find . -mindepth 3 \;`    |
| `-not` or `!` | 조건 부정             | `find . ! -name "*.c"`          |
| `-or`         | OR 조건             | `find . -name "*.c" -or -name "*.h"`    |
| `-and`        | AND 조건(기본)        | `find . -type f -and -size +1M`|


### 3) stat
- 파일이나 파일 시스템의 상세 정보를 표시하는 커맨드 라인 툴
```bash
$ stat [옵션] [파일]
```
Access : 파일을 사용한(읽어본) 시점
Modify : 파일의 내용이 변경
Change : 파일의 메타데이터가 변경


### wc
- 
```bash
$ wc [옵션] [파일]
```

### df
- 
```bash

```

### du
- 
```bash

```

### tar
- 
```bash
$ tar [옵션] [-f 아카이브파일] [파일]
```
- 


### read
- 
```bash
$ read [옵션] [변수]
```

### tr
- 
```bash
$ tr [옵션] 문자1 [문자2]
```











---

### memo
- 
