## 임베디드 리눅스 시스템

linux @ i386 (pc)
linux @ ARM/PPC (non PC) -> embedded linux by "porting"

    1. boot loader("u-boot")

    linux/Makefile -> make -> 1. vmlinux(linux exe)

    vmlinux -> vmlinux.gz -> zImage
    2. vmlinux -> Image -> zImage // kernel image

    3. device tree

    4. root file system
        ext4 on "/"(= root) 여러가지 파일 시스템이 마운트 되어 있음


### 파일 시스템이란
각각의 디렉토리마다 포맷이 상이한 파일시스템들이 지배한다


### 마운트

### 시스템 콜
유저 영역에서 Instruction을 통해 커널 영역의 기능을 요청(svc 등)


### 파일 처리와 표준 입출력
#### 고수준 입출력
- user space
```c
FILE *fp = fopen("data.txt", "r")
fread
fwrite
fclose
```

#### 저수준 입출력
- kernel space (device driver)
```c
int fd = open("data.txt", O_RDWR);
printf("%d", fd);
read
write
close(fd)
```


### 리눅스 파일 구조
- /proc : 커널이 관리하는 오픈 된 정보
- /sys  : 드라이버들이 오픈해놓은 정보
- /bin  : instruction


#### 유닉스 파일 시스템
- 하드디스크
- 디렉토리
- 키보드, 모니터
- 네트워크 카드, 사운드 카드
- 시스템 정보(kernel)
- 드라이버 정보(device driver)

> 파일을 오픈해서 읽고 쓰고 닫는것처럼 모든 파일들을 같은 메커니즘으로 처리


#### file read system call
`size_t read(int fd, void *buf, size_t count);`
- fd: open으로 열린 파일을 가리키는 파일번호
- buf: 읽은 데이터를 저장할 공간
- count : 




### 파일 읽기
#### NonBlocking
- read의 기본은 blocking
- readn

```c
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>

int main(int argc, char const *argv[])
{
    char buf[20];
    fcntl(0, F_SETFL, fcntl(0, F_GETFL) | O_NONBLOCK);
    sleep(4);
    int numRead = read(0,buf,4);
    if(numRead > 0){
        printf("You said: %s", buf);
    }
}
```
`fcntl(0, F_SETFL, fcntl(0, F_GETFL) | 0_NONBOLCK);`
- 0 : stdin
- flag
- 
- non blocking
- 읽은 값을 버퍼에 쓰기 위해 void*로 buf를 인자로 준다

`int numRead = read(0, buf, 4)`
- 4개의 입력을 받는다
- read는 받은 버퍼 갯수

### 파일 쓰기
#### write system call
- 파일에 쓰기 위해서는 쓰기가 가능한 모드로 파일이 열려있어야 함
- 쓸 값을 버퍼로 전달하기 위해 const void*로 buf를 인자로 준다
```c
#include <unistd.h>
#include<stdio.h>
#include <fcntl.h>
#include <string.h>

int main()
{
        int fd;
        int i;
        int wdata=0;
        int wsize=0;
        fd = open("data.txt", O_CREAT|O_WRONLY);
        if(fd<0)
        {
                perror("file open error");
                return -1;
        }
        for(i=0; i<100; i++)
        {
                wdata=i*2;
                wsize=write(fd, (void*)&wdata, sizeof(int));
                printf("Write %d(%d byte)\n", wdata, wsize);
        }
        close(fd);
}
```




### 동기화
#### sync
`#include<unistd.h>`


### Direct I/O
#### 드라이버 관련

### 파일 탐색
```c
#include<sys/types.h>
#include<unistd.h>
off_t lseek(int fd, off_t pos, int origin);
```
#### origin 값에 따른 작동 방식
- `SEEK_CUR`
  - pos가 0이면 현재위치 값을 출력하고, 그렇지 않은면 현 위치 값에 pos값을 더한 값을 리턴
- `SEEK_END`
- `SEEK_SET`

> 리턴값: 오류가 발생하면 -1, 성공했을 때는 파일의 시작으로부터의 offset을 리턴


### Multiplexed I/O


#### FD 관리를 위한 매크로들
- MUX

- FD_ZERO           : FD 집합 소거하기
- FD_SET / FD_CLR   : 
- FD_ISSET          : 


#### 입출력 다중화 (방법)
- 동기성을 유지
- 입출력 다중화 Select 방법


- FD가 뭐야


#### 파일의 권한과 모드


#### 표준 입력/출력/에러
표준 입력
- file descripter : 0
- 키보드 입력
표준 출력
- file descripter : 1
- 모니터 출력
표준 에러
- file descripter : 2
- 모니터 출력


#### 리다이렉션
- `>` 같은거
- `dup2(int oldfd, int newfd)`
- newfd가 oldfd의 복사본 처럼 동작한다


#### 입출력 버퍼 지우기

I/O 스케줄러(io sch)

- `fflush`

#### 파일 생성 모드 설정
기본 644
umask로 조절 가능

### 디렉터리와 시간 처리

#### 현재 디렉터리 
`getcwd()`
#### 디렉터리 생성
`mkdir()`

삭제
이동
접근


### 유닉스의 시간

mktime
time
localtime
tm



### GPIO 다루기
#### sys/class
#### fd
#### pinout.xyz
#### wiringpi


### PWM



#### 센서
- 부저




### 프로세스와 스레드

ps
kill
top
nice
#### 리눅스의 프로세스 상태
- TASK_RUNNING
- TASK_INTERRUPTIBLE
- TASK_UNINTERRUPTIBLE
- TASK_STOPPED
- TASK_ZOMBIE
  - pcb에는 있는데 실제로 동작하지 않는 상태
  - <defunct>

#### 프로세스의 기본 개념
- Fork
- Wait
- Exit

#### 문맥 교환과 문맥 저장 장소
- 문맥
  - 
fork(): 프로세스 생성
exec(): 프로그램 로드

####o for
1,;/2 3 

PID

< 0
== 0
\> 0


#### 리눅스 스케줄링 정책

- dynamic
  - PRI = 80+nice(-20 ~ +19)
  - 60 <= PRI <= 99

  - CFS - Completelly Fairness Schedule
  - vruntime = 적체수행시간(가상시간: 가중치 적용)


- static
  - RR 라운드 로빈
  - FIFO 

리눅스 **프로세스 스케줄링**을 핵심 위주로 정리해줄게.
(면접·과제·시스템 이해용으로 바로 쓰기 좋게)

---

### 1️⃣ 스케줄링이란?

👉 **여러 프로세스/스레드 중에서 지금 CPU를 누가 쓸지 결정하는 것**

* 단일 CPU라도 “동시에” 실행되는 것처럼 보이는 이유
* 커널의 **스케줄러(scheduler)**가 담당

---

### 2️⃣ 리눅스 스케줄링의 큰 구조

리눅스는 **우선순위 + 정책(policy)** 기반 스케줄링을 사용함.

### 스케줄링 클래스 (Scheduling Class)

리눅스는 여러 정책을 **클래스 단위**로 관리함:

우선순위 (높음 ↓ 낮음)

1. **Realtime (RT)**

   * `SCHED_FIFO`
   * `SCHED_RR`
2. **CFS (Completely Fair Scheduler)**

   * `SCHED_OTHER` (기본)
   * `SCHED_NORMAL`
3. **IDLE**

   * `SCHED_IDLE`

👉 **RT 프로세스가 하나라도 runnable이면 CFS는 못 돎**

---

### 3️⃣ 기본 스케줄러: CFS

### 🎯 목표

> “모든 프로세스가 CPU를 **공평하게** 사용하게 하자”

---

### 🔹 핵심 개념 1: Virtual Runtime (vruntime)

* 실제 실행 시간 × 가중치
* **CPU를 많이 쓴 프로세스일수록 vruntime 증가**
* 스케줄러는
  👉 **vruntime이 가장 작은 프로세스**를 선택

---

### 🔹 핵심 개념 2: nice 값

```bash
nice 값 범위: -20 (높은 우선순위)
            ~
             19 (낮은 우선순위)
```

* nice ↓ → 더 자주 CPU 받음
* nice ↑ → 덜 받음

```bash
nice -n -10 ./a.out
```

---

### 🔹 자료구조

* **Red-Black Tree**
* 키(key): `vruntime`
* 가장 왼쪽 노드 = 다음 실행 대상

---

### 4️⃣ 실시간 스케줄링 (RT)

### ① `SCHED_FIFO`

* **선점 없음**
* 높은 우선순위 프로세스가

  * 스스로 `block` 또는 `exit` 할 때까지 계속 실행
* 잘못 쓰면 **시스템 멈춤**

---

### ② `SCHED_RR`

* Round Robin
* 같은 우선순위 RT 프로세스끼리

  * **타임 슬라이스**로 번갈아 실행

---

### RT 특징 요약

* nice 값 무시
* CFS보다 항상 우선
* 임베디드/실시간 시스템에서 사용

---

### 5️⃣ 프로세스 상태와 스케줄링

주요 상태:

* `TASK_RUNNING` → 실행 가능
* `TASK_INTERRUPTIBLE` → sleep (signal로 깨어남)
* `TASK_UNINTERRUPTIBLE` → I/O 대기
* `ZOMBIE` → 종료했으나 wait 안 됨

👉 **RUNNING 상태만 스케줄 대상**

---

### 6️⃣ 컨텍스트 스위칭

프로세스가 바뀔 때 커널이 하는 일:

* 레지스터 저장/복원
* 스택 교체
* MMU 주소 공간 변경

👉 비용 큼 → 너무 잦으면 성능 저하

---

### 7️⃣ 멀티코어에서의 스케줄링

* 각 CPU마다 **runqueue** 존재
* **Load Balancing**

  * CPU 간 프로세스 이동
* CPU affinity 설정 가능

```bash
taskset -c 0 ./a.out
```

---

### 8️⃣ 면접용 핵심 요약

* 기본 스케줄러: **CFS**
* 기준: **vruntime**
* 자료구조: **Red-Black Tree**
* RT 정책은 CFS보다 항상 우선
* 좀비는 스케줄 대상 ❌

---

### 한 줄 요약

> “리눅스는 CFS를 사용해 vruntime 기준으로 공정하게 CPU를 분배하고, 실시간 프로세스는 그보다 높은 우선순위를 가진다.”

---

원하면 다음도 바로 이어서 설명 가능해:

* 스케줄링과 **fork/exec** 관계
* 스레드 vs 프로세스 스케줄링
* 임베디드 리눅스에서 RT 튜닝 포인트
* CFS 타임 슬라이스 계산 방식



응, **완전히 다른 개념**이야.
헷갈리기 쉬운데, 기준축이 아예 달라.

---

### 핵심 한 줄

* **정적 / 동적 스케줄링** → ❝ *언제* 스케줄을 결정하느냐 ❞
* **선점 / 비선점** → ❝ *강제로* CPU를 빼앗을 수 있느냐 ❞

---

### 1️⃣ 정적 스케줄링 (Static Scheduling)

### 의미

* **실행 전에** 어떤 작업이 언제 실행될지 **미리 결정**
* 실행 중에는 변경 ❌

### 특징

* 예측 가능성 ↑
* 오버헤드 ↓
* 유연성 ↓

### 예

* 임베디드 RTOS (타이머 테이블 기반)
* 컴파일 타임 스케줄
* 하드 실시간 시스템

```text
Task A → Task B → Task C (고정)
```

---

### 2️⃣ 동적 스케줄링 (Dynamic Scheduling)

### 의미

* **실행 중에** 상태를 보고 스케줄 결정
* 런타임마다 바뀜

### 특징

* 유연성 ↑
* 오버헤드 ↑
* 예측성 ↓

### 예

* **리눅스 CFS**
* 대부분의 범용 OS

```text
현재 vruntime 제일 작은 놈 실행
```

---

### 3️⃣ 선점 스케줄링 (Preemptive)

### 의미

* 실행 중인 프로세스를 **강제로 중단** 가능
* 더 높은 우선순위 프로세스가 오면 교체

### 특징

* 응답성 ↑
* 컨텍스트 스위치 ↑

### 예

* 리눅스 CFS
* RTOS Preemptive Kernel

---

### 4️⃣ 비선점 스케줄링 (Non-preemptive)

### 의미

* 한 번 CPU 잡으면

  * **스스로 양보(block/exit)할 때까지 계속 실행**

### 특징

* 구현 단순
* 응답성 ↓
* 굶주림 위험 ↑

### 예

* `SCHED_FIFO`
* 옛날 유닉스
* 단순 RTOS

---

### 5️⃣ 서로 섞일 수 있다 (중요)

이 네 개는 **독립적인 축**이라 조합 가능함.

| 조합       | 가능? | 예            |
| -------- | --- | ------------ |
| 정적 + 비선점 | ⭕   | 단순 RTOS      |
| 정적 + 선점  | ⭕   | 우선순위 기반 RTOS |
| 동적 + 선점  | ⭕   | **리눅스 CFS**  |
| 동적 + 비선점 | ⭕   | FIFO 큐 기반 OS |

---

### 6️⃣ 리눅스에 적용하면

* **동적 스케줄링** ✅
* **선점 스케줄링** ✅
* (RT 정책 중 `SCHED_FIFO`는 **비선점**)

---

### 면접용 정리 멘트

> “정적/동적은 스케줄을 언제 결정하느냐의 문제고, 선점/비선점은 실행 중인 작업을 강제로 중단할 수 있느냐의 문제라 서로 다른 개념이다.”

---

원하면

* RTOS vs 리눅스 스케줄링 비교
* FIFO가 왜 위험한지 실제 사례
* 선점 커널과 non-preempt 커널 차이

이것도 바로 이어서 정리해줄게.



#### 리눅스에서 제공하는 스케줄링 정책 그룹
- SCHED_NORMAL
  - 사용자 프로세스에 적용되는 스케줄링 정책
- SCHED_FIFO
  - 실시간 프로세스에 적용되는 스케줄링
- SCHED_RR
  - 실시간 프로세스에 적용되는 스케줄링

#### PRIORITY 설정 방법

#### 리눅스의 프로세스와 라이프사이클

- fork()
        - task_struct : PCB or TCB
        - proc에 존재



1. new
2. ready (ready-queue)
  - priority
    - dynamic
        - nice
            - CFS
              - 완전공평
              - vruntime : 적제총수행시간
    - static
        - RT-realtime(deprecated?)
        - 우선순위가 같을 때
               - RR
               - FIFO

3. cpu
4. sleep (wait-queue)
  - interrupt
  - non-interrupt
5. ready 
6. cpu
7. zombie(a moment)

`top`?

### 시그널
- 커널을 통해 프로세스에게 전달하는 비동기적 이벤트

1. kernel ----> process(user process)
2. process <--> process(IPC)

+시그널은 인터럽트로 구현되는가
> 시그널은 커널이 유저 프로세스의 실행 흐름에
비동기 이벤트로 개입할 수 있도록 만든 메커니즘이고,
Ctrl+C 같은 하드웨어 인터럽트도
프로세스에 전달되기 위해 시그널 형태로 변환된다.


#### 시그널 이벤트 종류

#### 시그널 처리기 함수
sigaction()
- 시그널 처리기를 설치
  - 구조체가 추가
signal()
- 시그널 처리를 설정



#### 멀티 프로세스와 다중 처리 프로그래밍

### 리눅스 부팅 요소 on rpi
#### bootloader
- uboot, startX.elf
- ram controller 초기화 : ram을 초기화한다 -> 램이 살아난다
- zimage 압축 해제


- vmlinux가 올라감
- 마운트

#### kernel
- vmlinux -> zImage (압축된 커널 이미지) : kernel8.img
- `sbin/init`

#### device tree
- bcm2711-rpi-4-b.dtb

#### rootfilesys
- dev/mmcblkOp2 on / type ext4




###
#### sync
USART(clock line을 공유해서 UART보다 더 빠름)
sync/async

#### async
UART
sync

+동기/비동기입출력

#### 동기화
배타적 실행(mutually exclusive execution)

순서적 실행
  할당된 이전 동작이 실행되지 않으면 공유 데이터에 접근하는 자리가 비어있어도 실행되지 않음


#### exeption
  - instruction에 의해 발생
        - clock의 주기마다 실행

        ```
        *p = 1; // p 0x0
        ie, STR r1, [r2]; // r1=1, r2=0

                -> MMU abort
                -> data abort !exception 발생
        ``` 

> 내부적으로 동작하는 instruction의 익셉션은 동기적

#### interrupt
        i1
        i2
pc->    i3      interrupt! PC --> IVC(NIVC?) --> irqHandler --> handling
        i4

___|___|___|___|___|___|
           ^
           i3

> 외부적으로 동작하는 프로세스의 인터럽트는 비동기적 (발생한 시점과 처리하기 시작하는 시간의 차이가 발생함)





###
#### return
- main에서 return을 호출하면 exit()이 호출된다
#### exit

- exit(exitstatus)
  - 프로세스 자체를 끝내는것
- pthread_exit()
- return()
  - 쓰레드를 끝내는것


### IPC
- 시그널
#### 파일 디스크립터 기반의 IPC
  - 파이프
  - FIFO
  - 소켓
 
#### 파이프
`$ ps -e | grep a.out`

- 단 방향 통신 채널
- Un-named pipe     :  쓰레드간, 혹은 부모-자식간 사용
- Named pipe(=FIFO) :  개별 프로세스 간 사용


> 부모 프로세스 <-> 자식 프로세스 : 파이프
> 개별 프로세스 <-> 개별 프로세스 : 메시지 큐, 공유 메모리, FIFO, 소켓

#### Un-named pipe
- FD 방식으로 구현
- parent
  - .text
  - .data (global var)
  - .STACK_p

  - file disk table

- child
  - .text : 공유
  - .data (global var) : 개별
  - .STACK_p : 개별

  - fdt : 공유

#### Named pipe
- FIFO
`~/exercise_lsp/12/12-2.name_pipe.c`

- 소켓?


#### 메시지 큐
- QCB
- 메모리(시스템 풀 또는 프라이빗 버퍼)

메시지큐는 생성될 때 qcbm 이름, 고유id 메모리 버퍼, 큐의 전체 길이, 최대 메시지 길이, 하나이상의 태스트 대기리스트를 할당 받는다

qcb와 태스크 대기 리스트를 생성하고 고유 ID를 메시지 큐에 할당하는것은 커널이 담당한다

수신 태스크 대기 리스트
송신 태스크 대기 리스트

- 메시지큐의 흐름도

- 다양한 데이터를 보내고 받을 수 있다
- 메시지의 길이가 매우 큰 경우 데이터 포인터를 메시지로 보내는 방법을 사용
- 다른 태스크로 메시지를 보낼 때, 메시지는 보통 두 번 복사된다
  - 송신 태스크의 메모리 영역 -> 메시지 큐의 메모리 영역 -> 수신 태스크의 메모리 영역
  - 빠른 처리를 위해 임베디드에서는 적은양의 데이터나 데이터 포인터를 사용하는 것이 좋다

prio 값을 정할 수 있음

- 메시지 큐 속성 구조체
```c
struct mq_attr {
flag
maxmsg
msgsize
curumpgs
}
```

#### 공유 메모리
프로세스 끼리 자신이 할당받은 메모리를 공유함으로써 메모리를 절약
메모리 매니저(MMU?)가 같은 물리 메모리주소를 각각 할당해준다

메모리에 접근할 때 데이터 훼손이 있을 수 있으므로 동기화 상호배제(동기화) 기법이 필요하다


#### 쓰레드간 통신




#### 유닉스 SysV의 IPC
#### 메시지 큐
    key_t ftok(char *pathname, char proj)
    메시지 큐 생성 : key 사용

```c
struct msgbuf {
        long mtype; // message type, mut be >0
        char mtext[1]; // message data array
}
```
  - mtype = 5  : 양수, 해당하는 type 번호를 가져온다
  - mtype = -2 : 음수, 해당 번호의 **절대값**보다 작거나 같은 값을 가져온다 //deprecated
  - mtype = 0  : zero, 순서대로 가져온다

#### 공유 메모리
##### non-named
- 부모 자식
- `12-6.shm_test_a.c`
- 공유 메모리 할당
- key : const, 접근하기 위한 key 값(프로세스 간 동일값을 사용해야 한다)
- `shmid int shmget(key_t key, size_t sizze, int shmflg)`
- size : 공유 메모리의 최소크기
- shmflg : 공유 메모리 메모리 플래그


  - 세마포어



- POSIX기반의 IPC
  - 메시지 큐
   `/home/ottl/exercise_lsp/12/12-4.posix_mq`
   `cc 12-4.posix_mq_a.c -lpthread -lrt`

  - mmap(공유메모리)
  - 네임드 세마포어



### 스레드 사용법
생성
`pthread_create()`
종료
`pthread_exit()`
조인
- `pthread_join()`을 사용하여 호출

pthread_once
pthread_cancel
pthread_attr_init
  - inherit


#### pthread
- pthread 구조체
- 우선순위
  - FIFO
  - RR
  - NORMAL
`/home/ottl/exercise_lsp/10`

- LWP
`pthread_test_a.c`
- exit
`pthread_exit_x.c`
- 


# [개념 슬롯]
## 임시 이름:
리눅스의 쓰레드 구조

## 한 줄 요약:
프로세스는 자식 쓰레드를 가질 수 있으며 기본적으로 단일의 메인 쓰레드를 가지고 있다

## 키워드:
- main thread(=leader thread)
 - join
- child thread
- exit() : 프로세스의 종료
- pthread_exit() : 해당 쓰레드의 종료

---

# [개념 슬롯]
## 임시 이름:
리눅스의 쓰레드

## 한 줄 요약:
리눅스는 쓰레드를 하나의 가벼운 프로세스로 정의했다

## 키워드:
- LWP

## 헷갈린 점:

---

# [개념 슬롯]
## 임시 이름:
멀티 프로세스와 멀티 쓰레드

## 한 줄 요약:
병렬 프로세싱을 위해 적절히 활용해야한다

## 키워드:
- multi processing
  - 오류로 인해 종료 되면 다른 프로세스에 영향을 준다
  - IPC, 문맥교환에 오버헤드가 커서 무겁다
    - 캐시를 활용할 수 없다
- multi threading
  - 위험하다
    - 오류로 인해 종료 되어도 다른 쓰레드에 영향을 준다
    - 디버깅이 어렵다
  - 가볍다
    - 통신을 위해 사용 : 전역 변수
    - 캐시를 활용할 수 있다

## 헷갈린 점:


---

# [개념 슬롯]
## 임시 이름:
캐시의 종류
## 한 줄 요약:

## 키워드:
- DATA : d-c
  - 이전에 썼던 데이터를 보유 (LSU)
- TEXT : i-c
  - 이전에 썼던 instruction을 보유 (IF와 관련)
- ADDR : TLB
  - 이전에 썼던 Translation table(가상 주소 -> 물리 주소 변환)

## 헷갈린 점:

---

# [개념 슬롯]
## 임시 이름:
오버헤드

## 한 줄 요약:
한 동작을 수행하기 위해서 추가적으로 사용되는 리소스
## 키워드:
장단점을 명확히 알고 적절히 감수하는 것

## 헷갈린 점:


---

# [개념 슬롯]
## 임시 이름:
쓰레드의 특징
## 한 줄 요약:

## 키워드:
- 프로세스 주소공간 공유
- 독립적인 문맥과 스택
- 공유 자원의 동기화 필요
- 문맥 전환 시 상대적으로 적은 오버헤드

## 헷갈린 점:
- 스레드는 레지스터가 개별로 존재


---

# [개념 슬롯]
## 임시 이름:
쓰레드의 특징

## 한 줄 요약:
스레드는 공유되는 것과 공유되지 않는것이 있다

## 키워드:
공유 되는것
- 작업 디렉터리
- 파일 지시자
- 전역변수, 데이터
- UID, GID
- signals/signal handlers
공유되지 않는것
- 스레드 id


## 헷갈린 점:




---

# [개념 슬롯]
## 임시 이름:
pthread: POSIX thread

## 한 줄 요약:
유닉스의 POSIX 표준으로 유저 영역에서 쓰는 pthread를 라이브러리 형태로 제공한다

## 키워드:


## 헷갈린 점:



---

## [개념 슬롯]
### 임시 이름:
cpu 병렬처리
### 한 줄 요약:

### 내용:
단일 cpu : simultaneous parallel processing
ie, RTos
멀티 cpu : true         parallel processing
ie, linux

### 키워드:

### 질문:


---

## [개념 슬롯]
### 임시 이름:
프로세스의 동기화
### 한 줄 요약:
두 개 이상의 프로세스가 동일한 자원에 접근할 때 일관성을 보장해야 한다
### 내용:
세마포어
뮤텍스
조건변수

### 키워드:
critical section : 코드상에서 공유된 자원에 접근하는 부분

### 질문:
스레드는 각각의 pc를 두는건가? pc를 우선순위에 따라 나눠쓰는가? 멀티 cpu라면?

---


## [개념 슬롯]
### 임시 이름:
세마포어의 개념
### 한 줄 요약:

### 내용:
네덜란드말로 철도건널목에있는그거
up : 0 -> 1
down : 1 -> 0

정의
여러 태스크가 동기화를 목적으로 획득하거나 반환할 수 있는 커널 오브젝트, 동기화 객체
태스크를 배타적으로 자원에 접근할 수 있도록 한다

유형
binary semaphore
counting semaphore

연산
initialize(create)
wait(pend)
signal(post)

세마포어가 생성될 때 커널이 하는일
SCB를 생성한다
ID 값 할당
초기값 설정 : 1이면 binary, 1보다 크면 counting
  
프로세스를 세마포어 대기 리스트에 할당한다 //프로세스가아니라 태스크에 해당하나

### 키워드:

### 질문:
프로세스 스케줄링과 같은역할이지 않나
세마포어 사용으로 인한 프로세스의 상태
cpu를 할당받는것과 다른거지않나


---


## [개념 슬롯]
### 임시 이름:
바이너리 세마포어
### 한 줄 요약:

### 내용:
0일때 사용 불가능(empty)
1일때 사용 가능(full)

0 또는 1로 초기화된다
1 : 배타적 사용
0 : 순서적 사용

### 키워드:


### 질문:
순서적 사용에서 세마포어가 0인게 세마포어가 이전 동작을 바라보고있는건가? 그럼 세마포어는 프로세스 당 설정된게아닐 수 있는게 커널 오브젝트기 때문인가? 그럼 공유 메모리마다 세마포어가 하나씩 있는가? 세마포어가 어디에 달려있는가. CPU를 점유하는건가

---


## [개념 슬롯]
### 임시 이름:
POSIX 세마포어의 사용법
### 한 줄 요약:

### 내용:
유형
un-named semaphore
named semaphore
API
sem_wait
sem_trywait
sem_post
sem_getvalue
sem_destroy : 이름 없는 세마포어 제거
sem_close : 이름 있는 세마포어 제거
sem_inlink : 이름 있는 세마포어의 링크를 제거, 다른 프로세스들이 참조하고 있다면 block 되었다가 아무도 참조하지 않는 시점에 제거


### 키워드:
blocking, non-blocking : 함수가 정상적으로 실행되지 않아도 머무를지 탈출할지
deadlock : 서로가 부족한 세마포어를 계속 가지고 있어서 block이 발생, 가급적 세마포어를 겹쳐서 쓰면 안된다

### 질문:

---


## [개념 슬롯]
### 임시 이름:
뮤텍스의 개념

### 한 줄 요약:

### 내용:
상호 배제 세마포어 (**Mut**ually **Ex**clusive semaphore)

상호배제를 위해 사용

바이너리 세마포어처럼 동작
소유권, 재귀적 접근, 태스크 삭제 보호, 우선 순위 역전 회피 프로토콜 등을 지원한다

POSIX mutex
pthread_mutex_t
pthread_mutex_lock
pthread_mutex_trylock
pthread_mutex_unlock


### 키워드:
lock, un-lock
lock count
ROBUSTNESS
Condition variable : 뮤텍스의 순서적 사용
### 질문:
세마포어와 주요 차이점


---


## [개념 슬롯]
### 임시 이름:
네트워크 구성요소

### 한 줄 요약:

### 내용:
//
//
//
gateway / switch
router
  최단경로 계산
bridge
hub
switch

### 키워드:

### 질문:

---


## [개념 슬롯]
### 임시 이름: 
프로토콜

### 한 줄 요약:
양 끝단 간의 연결, 통신, 데이터 전송을 위한 규약
### 내용:

### 키워드:
protocol stack

reliable data transfer : 
flow control : 
congestion control : 부하를 조절

circuit switching, packet switching 
### 질문:

---


## [개념 슬롯]
### 임시 이름:
OSI 7 layer 
### 한 줄 요약:

### 내용:
application
  - application
  - presentation
  - session
data flow
  - transport
  tcp header
  - network
  ip header
  - data link
  llc header 
  - phsical
  mac header 
### 키워드:

### 질문:

---



## [개념 슬롯]
### 임시 이름:
IP addressing
### 한 줄 요약:

### 내용:
network portion
node portion

Class A node portion : 24 bit
Class B node portion : 16 bit
Class C node portion : 8 bit
Class D node portion : 0 bit - 

IP addressing - Subnetting
  node portion을 퍼포먼스를 위해 쪼갠다
### 키워드:

### 질문:

---



## [개념 슬롯]
### 임시 이름:
TCP 개념
### 한 줄 요약:

### 내용:
three way handshake
port number로 프로그램들을 구분한다

### 키워드:
connection oriented : TCP
connectionless : UDP

UDP

서비스
DHCP
SSH

### 질문:

---



## [개념 슬롯]
라우터
### 임시 이름:

### 한 줄 요약:

### 내용:
class B에서?

단일 네트워크의 단점을 보완
라우터라는 중간 매개를 둠

어떤 노드에서 특정 노드까지 데이터를 전달하기 위해 거쳐가는 라우터들은 network layer를 통해 전달해줌

라우터는 여러 패스를 보유하여 가장 효율적인 경로로 보낼 수 있게 라우팅 해준다

### 키워드:
Broadcast address
라우팅 테이블
라우팅 프로토콜
  동적
    RIP
    OSPF
    BGP
  정적
    사람이?

### 질문:
라우터끼리는 어떻게 연결되어 있는지


---
## [개념 슬롯]
### 임시 이름:
스위치 - 스위칭

### 한 줄 요약:

### 내용:
data link(layer2) 에서 동작
스위치는 MAC 주소를 보유

HUB : 전기적 연결만 가능. 스위치는 HUB + MAC 주소 스위칭

### 키워드:
MAC address
NIC

### 질문:

---



## [개념 슬롯]
### 임시 이름:

### 한 줄 요약:

### 내용:

### 키워드:

### 질문:

---



## [개념 슬롯]
### 임시 이름:

### 한 줄 요약:

### 내용:

### 키워드:

### 질문:

---



## [개념 슬롯]
### 임시 이름:

### 한 줄 요약:

### 내용:

### 키워드:

### 질문:

---



## [개념 슬롯]
### 임시 이름:

### 한 줄 요약:

### 내용:

### 키워드:

### 질문:

---



## [개념 슬롯]
### 임시 이름:

### 한 줄 요약:

### 내용:

### 키워드:

### 질문:

---



## [개념 슬롯]
### 임시 이름:

### 한 줄 요약:

### 내용:

### 키워드:

### 질문:

---



## [개념 슬롯]
### 임시 이름:

### 한 줄 요약:

### 내용:

### 키워드:

### 질문:

---
---
### +추가
## POSIX
AT&T가 UNIX를 만들기 위해 C언어를 만듬

반독점 금지법으로 인해

기업(IBM, ...) -> SysV, SCO
학교(Berkley, ...) -> 네트워크 연구 -> 소켓

으로 나뉘게 됨

IBM의 제각각이였던 라이브러리로 인해 Windows NT로 사용자들이 몰리게 되었고
위기감을 느낀 IBM이 표준화를 제안하며 POSIX가 등장함

