## 임베디드 리눅스 시스템

linux @ i386 (pc)
linux @ ARM/PPC (non PC) -> embedded linux by "porting"

    1. boot loader("u-boot")

    linux/Makefile -> make -> 1. vmlinux(linux exe)

    vmlinux -> vmlinux.gz -> zImage
    2. vmlinux -> Image -> zImage // kernel image

    3. device tree

    4. root file system
        ext4 on "/"(= root) 여러가지 파일 시스템이 마운트 되어 있음


### 파일 시스템이란
각각의 디렉토리마다 포맷이 상이한 파일시스템들이 지배한다


### 마운트

### 시스템 콜
유저 영역에서 Instruction을 통해 커널 영역의 기능을 요청(svc 등)


### 파일 처리와 표준 입출력
#### 고수준 입출력
- user space
```c
FILE *fp = fopen("data.txt", "r")
fread
fwrite
fclose
```

#### 저수준 입출력
- kernel space (device driver)
```c
int fd = open("data.txt", O_RDWR);
printf("%d", fd);
read
write
close(fd)
```


### 리눅스 파일 구조
- /proc : 커널이 관리하는 오픈 된 정보
- /sys  : 드라이버들이 오픈해놓은 정보
- /bin  : instruction


#### 유닉스 파일 시스템
- 하드디스크
- 디렉토리
- 키보드, 모니터
- 네트워크 카드, 사운드 카드
- 시스템 정보(kernel)
- 드라이버 정보(device driver)

> 파일을 오픈해서 읽고 쓰고 닫는것처럼 모든 파일들을 같은 메커니즘으로 처리


#### file read system call
`size_t read(int fd, void *buf, size_t count);`
- fd: open으로 열린 파일을 가리키는 파일번호
- buf: 읽은 데이터를 저장할 공간
- count : 




### 파일 읽기
#### NonBlocking
- read의 기본은 blocking
- readn

```c
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>

int main(int argc, char const *argv[])
{
    char buf[20];
    fcntl(0, F_SETFL, fcntl(0, F_GETFL) | O_NONBLOCK);
    sleep(4);
    int numRead = read(0,buf,4);
    if(numRead > 0){
        printf("You said: %s", buf);
    }
}
```
`fcntl(0, F_SETFL, fcntl(0, F_GETFL) | 0_NONBOLCK);`
- 0 : stdin
- flag
- 
- non blocking
- 읽은 값을 버퍼에 쓰기 위해 void*로 buf를 인자로 준다

`int numRead = read(0, buf, 4)`
- 4개의 입력을 받는다
- read는 받은 버퍼 갯수

### 파일 쓰기
#### write system call
- 파일에 쓰기 위해서는 쓰기가 가능한 모드로 파일이 열려있어야 함
- 쓸 값을 버퍼로 전달하기 위해 const void*로 buf를 인자로 준다
```c
#include <unistd.h>
#include<stdio.h>
#include <fcntl.h>
#include <string.h>

int main()
{
        int fd;
        int i;
        int wdata=0;
        int wsize=0;
        fd = open("data.txt", O_CREAT|O_WRONLY);
        if(fd<0)
        {
                perror("file open error");
                return -1;
        }
        for(i=0; i<100; i++)
        {
                wdata=i*2;
                wsize=write(fd, (void*)&wdata, sizeof(int));
                printf("Write %d(%d byte)\n", wdata, wsize);
        }
        close(fd);
}
```




### 동기화
#### sync
`#include<unistd.h>`


### Direct I/O
#### 드라이버 관련

### 파일 탐색
```c
#include<sys/types.h>
#include<unistd.h>
off_t lseek(int fd, off_t pos, int origin);
```
#### origin 값에 따른 작동 방식
- `SEEK_CUR`
  - pos가 0이면 현재위치 값을 출력하고, 그렇지 않은면 현 위치 값에 pos값을 더한 값을 리턴
- `SEEK_END`
- `SEEK_SET`

> 리턴값: 오류가 발생하면 -1, 성공했을 때는 파일의 시작으로부터의 offset을 리턴


### Multiplexed I/O


#### FD 관리를 위한 매크로들
- MUX

- FD_ZERO           : FD 집합 소거하기
- FD_SET / FD_CLR   : 
- FD_ISSET          : 


#### 입출력 다중화 (방법)
- 동기성을 유지
- 입출력 다중화 Select 방법


- FD가 뭐야


#### 파일의 권한과 모드


#### 표준 입력/출력/에러
표준 입력
- file descripter : 0
- 키보드 입력
표준 출력
- file descripter : 1
- 모니터 출력
표준 에러
- file descripter : 2
- 모니터 출력


#### 리다이렉션
- `>` 같은거
- `dup2(int oldfd, int newfd)`
- newfd가 oldfd의 복사본 처럼 동작한다


#### 입출력 버퍼 지우기

I/O 스케줄러(io sch)

- `fflush`

#### 파일 생성 모드 설정
기본 644
umask로 조절 가능

### 디렉터리와 시간 처리

#### 현재 디렉터리 
`getcwd()`
#### 디렉터리 생성
`mkdir()`

삭제
이동
접근


### 유닉스의 시간

mktime
time
localtime
tm



### GPIO 다루기
#### sys/class
#### fd
#### pinout.xyz
#### wiringpi


### PWM



#### 센서
- 부저




### 프로세스와 스레드

ps
kill
top
nice
#### 리눅스의 프로세스 상태
- TASK_RUNNING
- TASK_INTERRUPTIBLE
- TASK_UNINTERRUPTIBLE
- TASK_STOPPED
- TASK_ZOMBIE
  - pcb에는 있는데 실제로 동작하지 않는 상태

#### 프로세스의 기본 개념
- Fork
- Wait
- Exit

#### 문맥 교환과 문맥 저장 장소
- 문맥
  - 
fork(): 프로세스 생성
exec(): 프로그램 로드

####o for
1,;/2 3 

PID

< 0
== 0
\> 0








### 시그널
signal
sigaction





#### 리눅스 스케줄링 정책

- dynamic
  - PRI = 80+nice(-20 ~ +19)
  - 60 <= PRI <= 99

  - CFS - Completelly Fairness Schedule
  - vruntime = 적체수행시간(가상시간: 가중치 적용)


- static
  - RR 라운드 로빈
  - FIFO 



#### 리눅스에서 제공하는 스케줄링 정책 그룹
- SCHED_NORMAL
  - 사용자 프로세스에 적용되는 스케줄링 정책
- SCHED_FIFO
  - 실시간 프로세스에 적용되는 스케줄링
- SCHED_RR
  - 실시간 프로세스에 적용되는 스케줄링




---

### memo
- 스토리지클래스, 타입수식어, 라이프타임, 스코프 관계
- 스택에 잡히는 변수의 주소는 스택포인터의 상대적인 위치로 잡힌다
- 프로세스는 기본적으로 file description table을 가지고 있다
- fd가 머말하는건데
- 







- 와이어링파이
  - gpio  

콜로로스