# 7일차


## 리눅스 개발환경 도구
### Make / make
    in embedded system -> **C** /C++
    각각의 c 파일들을 자동으로 빌드하기 위한 시스템
    일종의 인터프리터 언어

#### Rule
```bash
target : prerequisites(=dependency)
    recipes # bash가 실행하는 파일
```
```bash
helloworld :
    @echo hello world
```


all 타겟 : 디폴트 타겟
```bash
all: bar baz
#       @echo foo
#2       @echo bar
#3       @echo baz

bar: 
        @echo bar

baz: 
        @echo baz
```
 # 공백 주의 - 출력 X
#### default makefile
1. GNUmakefile
2. makefile
3. Makefile

- -f : 파일 지정

#### make DB
- make가 관리하는 내부 database
- -p : 내부 DB를 print
```bash
$ make -p | grep -w CC
```

#### makefile debug
```bash
$ make -d
```

#### makefile 작성
```bash
VAR = world # 매크로 변수

hello:$(VAR)
    @echo hello \  # '\' 의미
    $(VAR)

:execute

$ make
helloworld
```

`$()` :  스크립트랑 다른거 맞나

```make
$(MAKE) -C subbir --no-print-directory
```

`:=` 는 뭐야

#### 하위 makefile과 연결
- 상속
- 포함

#### 파일 타겟

so trivial

#### 빌드
- 파일 타겟
- hello.c : 소스 코드
- hello.o - 목적 코드
- hello : 실행 코드(타겟)
- 의존 관계의 파악


#### 더미 타겟
- all:


#### 포니 타겟
- phony : 가짜, 위장, 사기 , 장난
- 동일한 이름의 파일이 있으면 더미 타겟으로 쓸 수 없는것을 해결

```bash
.PHONY
```

#### forced target
- 의존 더미 타겟

#### 2차 타겟
- 이차적 고려 대상의 중간 타겟


#### 싱글 첨자
-  싱글 서픽스 타겟

`SUFFIXES: .k`
임의의 확장자를 어떻게 처리할것인지
```bash
.c:
```

#### 더블 첨자
- 더블 서픽스 타겟
```bash
.c.o :          # .c파일로부터 .o파일을 만드는방법을 정의
```

#### Rule
- explict 
    - single suffix  rule   ie,     .c:
    - double suffix  rule   ie,   .c.o:
    - single pattern rule   ie,   %o %c
    - double pattern rule

- implict 
    - single suffix  rule
    - double suffix  rule
    - single pattern rule
    - double pattern rule


#### 내용 없는 규칙
#### 내용 추가
#### 내용 함수
#### 루프
#### 조건 실행
- makefile 문법


#### 정의 실행





<!-- 8일차 -->

#### 변수 정의
```bash
$(eval SAY=hello) # 로컬 변수 선언 in recipe
```
#### 변수 해제
```
bar = hello
undefine bar
```

#### 변수 참조
예제 052043

```bash
V := foo
V2 := bar
V3 := baz

all:
    @echo $V
    @echo $(V2)
    @echo ${V3} # 가급적 해당 문법을 사용

    @echo $V2 # foo2 출력
    @echo $( V3 ) # 공백 주의 - 출력 X
```

#### 변수 확장
##### `:=` : immediate expansion

```bash
foo := $(bar) # 변수가 존재하지 않아서 공백 대입
bar := hello
```
##### `=` : deferred / recursive expansion
```bash
foo = $(bar) # 호출 시점에 변수를 접근
bar := hello

all:
    @echo $(foo) # hello 출력
    @echo $(bar)
```
##### `+=` : appending expansion
```bash
foo = $(bar) # 호출 시점에 변수를 접근
bar := hello
bar += $(foo)

all:
    @echo $(foo) $(bar) # hello hello hello 출력
```

##### `?=` : weak expansion
```bash
say := hello
say ?= world # 이미 확장 된 변수에는 들어가지 않음

all:
    @echo $(SAY) # hello 출력
```

#### 변수 치환
substitution
```bash
OBJ := hello.o world.o
SRC := $(OBJ: .o=.c)

all
    @echo $(OBJ) # hello.o world.o 출력
    @echo $(SRC) # hello.c world.c 출력

```

#### 변수 환산
computed

```bash
foo = bar
bar = baz
baz = hello

all:
    @echo $($($(foo))) # 공백 ? 
```

#### 변수 공표
export

`.EXPORT_ALLVARIABLES:`
`export var1`
- 다른파일에서 사용한다는데 makefile만 가능한지

#### 자동 변수
```bash
$@ # traget

$^ # all prereq, list
$? # updated prereq, list
$< # 1st prereq, only

$(@D) # dir of target
$(@F) # name of target
$(<D) # dir of 1st prereq
$(<F) # name of 1st prereq
```

#### 문자 함수
#### 파일 함수
#### 조건 함수
#### 순회 함수
`$(사용)`



052041
052043
052044
052045
052046

변수 정의
변수 확장
변수 치환
변수 환산
변수 공표?
자동 변수

%.o:
%.o:%.c

---

### memo
- make 파일에서 환경변수 값을 사용할 수 있는지
