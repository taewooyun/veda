# 리눅스 디바이스 드라이버

## 임시 이름:
리눅스의 개발 요소
### 내용:
1. bootloader(u-boot)
2. device tree(overlay)
3. kernel(driver)
4. rootfilesystem(buildroot)

### 키워드:

---
## 임시 이름:
리눅스의 장점
### 요약:
리눅스는 **네트워크·성능·안정성·확장성·자율성**을 동시에 만족하는 OS이기 때문에 서버, 클라우드, 네트워크 장비, 임베디드까지 지배하고 있다.
### 키워드

---
## 임시 이름:
콘솔과 터미널
### 내용:
콘솔 : 물리 TTY
/dev/tty1
uart는 ttyS0를 쓴다
...
터미널 : 가상 TTY
/dev/pts/0
...
현재 터미널
/dev/tty
### 키워드

---
## 임시 이름:
리눅스의 실행환경
### 요약:
리눅스 포팅이란 특정 보드에 리눅스를 실행시키기 위해 각각의 하드웨어에 작업하는 일련의 과정을 일컫는다
### 내용:
1. CPU
    porting : X (manufacturer)
2. memory
    porting : 데이터시트를 참고, timing을 찾아서 커널에 맞춰줘야한다
3. console
    stdin, stdout, stderr
    일반적으로 구성이 되어 있지만 uart의 경우에는 필요할 수 있다
4. io (device/peripherals)
    장치 타입의 종류 마다 드라이버를 작성하는 방법이 다르다
    char  
    block 
    ...
    porting : driver 작성


---
## 임시 이름:
리눅스 커널 소스트리
### 내용:
주요 커널 소스
arch : 아키텍쳐 종속 코드
documentation : 커널 소스 문서
drivers : 디바이스 드라이버
include : 커널 헤더 파일들
init : 커널 부트와 초기화 관련
  - start_kernel : 커널이 시작할 때 최초로 실행되는 c 함수
ipc : 프로세스간 통신 코드
lib : 유틸리티 루틴


---
## 임시 이름:
드라이버 작성 시 고려 사항
### 요약:
실행영역 커널영역
  - 드라이버는 커널의 부분
  - 오작동 시 치명적 피해

콜백함수제공

커널기능이용
  - 메모리 할당
  - 인터럽트
  - 동기화

제작형태  결정
  - 커널형태
  - 모듈형태

---
## 임시 이름:
드라이버 소스 로케이션
### 한 줄 요약:

### 내용:
tree : kernel tree

in-tree
  /drivers/...
  커널 소스 트리 내에 hello.c
ex-tree
  /home/user/...

### 키워드:

### 질문:


---
## 임시 이름:
드라이버 제작 형태
### 요약:
dht11.c -> dht11.o ->
1. vmlinux : 커널 포함 형태
  - zImage에 내장
2. dht11.ko (*선호) : 커널 모듈에 탑재
  - kernel object
### 키워드:


---
## 임시 이름:
커널 소스
### 요약:
`/boot` 
1. kernel.org
2. linux-x.x.x.gz
  - kernel
    - vmlinux -> Image -> zImage (kernel8.img)
  - driverSource
    - `/lib/modules/6.1.21-v8+/kernel/drivers/`
  - divice tree
    - bcm2711-rpi-4-b.dtb
### 키워드:
start.elf : bootloader

---

## 임시 이름:
디바이스의 종류
### 요약:
문자 디바이스
- 바이트 단위 입출력
- /dev의 node를 통해 접근
    - /dev/console
    - /dev/ttyS0
- 주로 순차 참조
- keyboard, mouse, serial, modem, video,...

블록 디바이스
- 블록 단위 입출력 (버퍼 사용)
- /dev의 node를 통해 접근
    - /dev/sda
- 순차 및 랜덤 참조
- hard disk, cd-rom, usb disk,...

소스코드 위치
- drivers/char
- drivers/block
- drivers/misc
- drivers/input
- drivers/video
- drivers/i2c
- drivers/iio

### 키워드:

---

## 임시 이름:
유저 영역에서 커널 영역의 자료 참조
### 요약:
`/proc` : 커널이 오픈한 정보를 인터렉티브하게 열람하는 곳
- /cpuinfo : cpu의 정보
- /meminfo : 메모리 정보
- /proc : 커널의 명령행 인자
`/sys`  : 드라이버가 오픈한 정보를 인터렉티브하게 열람하는 곳
- /firmware
- bus
- device
- class

### 키워드:

---

## 임시 이름:
리눅스 커널 설치 및 빌드
### 요약:
upstream : 원본 저장소
[https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags]

fetch : 원격 저장소에서 소스 코드를 가져오는 단계
unpack : 압축된 소스를 해제하는 단계
patch : 소스 코드에 수정 사항을 적용
configure : 커널 빌드 옵션을 설정하는 단계
- `$ apt install libncurses-dev flex bison`
- `$ make menuconfig`
- `$ export KERNEL=kernel8`
- `$ export ARCH=arm64`
`.config`에 설정이 반영된다
makefile
- obj-$(CONFIG_DHT11) += dht11.o
    - obj-m -> xxx.ko
    - obj-y -> vmlinux -> zImage
    - obj-  -> no compile

compile
link
install
exec

### 키워드:

---

## 임시 이름:
리눅스 디바이스 트리 구조
### 요약:
1. source files
    - .dts     (.c)
    - .dtsi    (.h)
2. complier
    - dtc
3. binaries
    - .dtb     (device tree blob)
    - .dtbo    (dtb overlay)


### 키워드:

---

## 임시 이름:
모듈 빌드 설정 및 실행
### 요약:
`/lib/modules/???`

`$ insmod .ko` : 모듈 삽입
`$ lsmod`      : 현재 탑재 된 모듈
`$ rmmod`      : 모듈 삭제

`printk()`     : 기본적으로 콘솔에 출력
- `$ cat /var/log/messages`
`$ dmesg`      : 모듈 메세지 출력
- `-c`         : 출력 후 클리어

### 키워드:

---

## 임시 이름:
리눅스 포팅의 흐름
### 요약:
1. bootloader(u-boot, ...) : start.elf를 호출해서 시작
2. device tree(overlay) : .dtb 파일
3. kernel(driver) : 드라이버 패치
4. rootfile system(buildroot, yocto, ...) : 루트 파일 시스템을 구축


### 키워드:

---

## 임시 이름:
모듈의 기본 형태 `module.h`
### 요약:
초기화 등록 함수
초기화 해제 함수
등록 매크로 제공(`linux/init.h`)

module_platform_driver()
module_i2c_driver()
module_usb_driver()
module_spi_driver()
module_pci_driver()

모듈 라이선스가 반드시 필요
`MODULE_LICENSE("GPL")`
- 경고 메세지, 기능에 제약

### 키워드:

---

## 임시 이름:
모듈 드라이버 매개변수 전달
### 요약:
`$ insmod .ko param=arg`
- `charp`
- `module_param_array`

### 키워드:

---

## 임시 이름:
커널 심볼 내보내기
### 요약:
주어진 심볼을 전역으로 내보내 다른 드라이버에서도 사용하도록 함

```bash
cat /proc/kallsyms | grep expo_
ffffffec1f377020 r __kstrtab_expo_vars  [51_dev]
ffffffec1f37702a r __kstrtabns_expo_vars        [51_dev]
ffffffec1f37700c r __ksymtab_expo_vars  [51_dev]
ffffffec1f37702b r __kstrtab_expo_func  [51_dev]
ffffffec1f377035 r __kstrtabns_expo_func        [51_dev]
ffffffec1f377000 r __ksymtab_expo_func  [51_dev]
ffffffec1f37701c r __crc_expo_vars      [51_dev]
ffffffec1f377018 r __crc_expo_func      [51_dev]
ffffffec1f376000 T expo_func    [51_dev]
ffffffec1f378010 D expo_vars    [51_dev]
```

```bash
cat /lib/modules/6.1.21-v8+/modules.dep | grep dht11
kernel/drivers/iio/humidity/dht11.ko.xz: kernel/drivers/iio/industrialio.ko.xz
```
- 의존관계가 저장됨


### 키워드:

---

## 임시 이름:
캐릭터 디바이스의 특징
### 요약:
간헐적 데이터
바이트 데이터 발생

### 키워드:

---

## 임시 이름:
Charactor device / Block device 를 식별하는 방법
### 요약:
장치번호 
장치 번호의 타입
- dev_t @ linux/types.h
    - Major(12bit), Minor(20bits)
장치 번호의 구성
- Major 번호
    - 디바이스 드라이버를 실행시킬 때 디바이스를 찾아가기 위해 디바이스트리가 존재한다
- Minor 번호
    - 동종 장치의 개별 식별을 위해 사용되는 번호
장치 번호 구성용 매크로
- `MAJOR(dev_t dev)` : 주 번호 추출
- `MINOR(dev_t dev)` : 부 번호 추출
- `MKDEV(int major, int minor)` : 장치 번호 생성
등록 장치 번호 확인
`# cat /proc/devices`

장치 번호를 지정하는 방법
- Documentation/devices.txt 참조
- `# cat /proc/devices`로 현황파악
- 장치에 예약된 번호를 사용하거나 새로운 장치번호를 부여 (~ 254) or (255 ~ 512)
- `register_chrdev_region()` 를 이용하여 직접 지정
    - `int register_chrdev_region(dev_t first, unsigned int count, char *name)`

장치 번호를 할당하는 방법
- 비어있는 번호를 자동으로 할당
- 254번 부터 큰값부터 할당
- `alloc_chrdev_region()` 사용
    - `int alloc_chrdev_region(dev_t *dev, unsigned int firstminor, unsigned int count, char *name)`

장치 번호를 할당하는 방법
- `unregister_chrdev_region()` 사용
    - `void unregister_chrdev_region(dev_t first, unsigned int count)`

### 키워드:

---

## 임시 이름:
문자 장치 표현
### 요약:
`linux/cdev.h`
cdev 구조체를 사용하여 캐릭터 디바이스를 표현한다

`cdev_init()`
`void cdev_add(struct cdev *cdev, dev_t num, unsigned int count)`
`void cdev_del(struct cdev *cdev)`

### 키워드:

---

## 임시 이름:
장치 파일의 생성 방법
### 요약:
1. `# mknod /dev/name type major minor`
2. `int mknod(const char *pathname, mode_t mode, dev_t dev)`
3. `struct device *device_create()`

### 키워드:

---

## 임시 이름:
드라이버 컨텍스트
### 요약:
어떤 경로로 드라이버를 찾아왔는가

1. TOP(application) --> driver
- 프로세스 컨텍스트
- 시스템 콜에 의해 실행
    - 유저 영역에서 호출한 open에 해당하는 함수를 구조체를 통하여 드라이버에 구현해야 한다
        - .open      = my_open,
        - .release   = my_release
2. Bottom(hardware) --> driver
- 인터럽트 컨텍스트
- 인터럽트에 의해 실행


### 키워드:

---

캐릭터 드라이버
file operation
.open
.release
.read
.wirte
.ioctl
callback function




커널에서 동적 메모리를 할당하기
커널 서비스
kmalloc
GFP_KERNEL : process context, blocked
GFP_ATOMIC : interrupt context, wait

메모리관리
버디 할당자
2^N page 단위로 할당
슬랩 할당자
kmem_cache에 정의한 cache

kmalloc() : 연속적으로 할당
- kfree()
vmalloc() : 비연속
- vfree()

인터럽트 처리

예외처리
- 아키텍쳐마다 다름
- 익셉션 벡터 테이블 -> 인터럽트 벡터 테이블 -> 인터럽트 처리 루틴

ISR 구현을 해본건가


dtoveraly

request irq

---

## 임시 이름:
TOP HALF와 BOTTOM HALF
### 요약:
io의 버퍼가 다 차기 전에 driver 버퍼에 인터럽트로 올리는 작업

Top half
urgent : by isr


Bottom half
deferrable : by kthread(wroker thread)
- softirq
    - 정적 생성
    - 성능 우수
    - 비권장
- tasklet
    - 동적 생성
    - softirq를 기반으로 발전 시킨 형태
    - 같은 타입의 태스크릿들이 동시에 실행 될 수는 없음
- workqueue
    - 우리가 필요한 bottom half는 프로세스적인 특징들이 필요하다
- threaded irq

### 키워드:

---

## 임시 이름:
Workqueue의 특징

### 요약:
커널 쓰레드를 생성하여 BH를 구현한다
프로세스 컨텍스트의 특징을 모두 갖는다
- 선점이 기능
- 인터럽트도 허용
- 휴면, 많은 메모리 할당, 세마포어 획득, 블록킹 I/O
글로벌 워크큐와 커스텀 워크큐 방식이 있다


### 키워드:

---

## 임시 이름:
kworker

### 요약:
deferred work를 담당하는 일꾼 커널 스레드들
워크큐에 등록된 타스크들을 하나씩 꺼내어 비동기적으로 처리한다

역할
- 커널이 인터럽트 핸들러나 기타 중요한 커널 스레드가 오랜 시간 동안 블록되는 것을 방지하기 위해, 시간이 오래 걸리거나 즉각적으로 처리할 필요가 없는 작업을 유크큐에 등록
- 워크큐에 쌓인 작업들을 하나씩 꺼내서 순차적으로 처리한다
- 이는 bh메커니즘의 한 종류, 커널 응답성을 유지하고 시스템의 안정성을 높이는데 중요한 역할을 담당
- ex) 파일 시스템 동기화, 장치 드라이버의 지연 작업, 메모리 관리 등 커널의 중요한 기능

생성
- schedule_work()/queue_work함수를 호출하여 작업을 워크큐에 추가할 때 커널은 내부적으로  kworker 스레드를 깨우거나

### 키워드:


---

## 임시 이름:
workqueue의 사용법

### 요약:
global
커널이 제공하여 이미 존재하는 workqueue를 사용하여 work만 넣어주면 됨

`struct work_struct work`
- 워크 선언
`INIT_WORK(&work, void (*function)(struct work_struct *))`
- 선언된 워크 큐 구조체 변수를 초기화하는 매크로
`DECLARE_WORK(wrok, void (*function)(struct work_struct *))`
- 선언과 함께 초기화

`int schedule_work(?)`
- 워커 스레드를 스케줄
`int schedule_dlayed_work(?)`
- 워커 스레드를 delay(jiffies) 만큼 지연시켜 스케줄
`int schedule_work_on(?)`
- 지정된 CPU에 스케줄
`int schedule_delayed_work_on(?)`
- 지정된 CPU에 지연시켜 스케줄

custom
workqueue와 work 둘 다 만들어야 함
`struct workqueue_struct *create_workqueue(const char *name)`
- 워크 큐를 생성하는 매크로
`void destry_workqueue(struct workqueue_struct *queue)`
- 워크 큐를 제거하는 매크로
`alloc_workqueue(fmt, flags, max_active)`
- flags의 종류
    - WQ_UNBOUND : ?
    - WQ_FREEZABLE : ?
    - HIGHPRI : ?
    - CPU_INTENSIVE : ?

`int queue_work(?)`
- 커스텀 워크를 워크 큐에 스케줄
`int queue_work_on(?)`
`int queue_delayed_work(?)`
`int queue_delayed_work_on(?)`

> 실습 2203, 2205

### 키워드:

---

## 임시 이름:
threaded irq의 사용법

### 요약:
IRQ 처리를 irq 핸들러와 kernel 스레드로 나누어 시간차로 처리하는 방식

작동 방식
- `request_threaded_irq()` 사용 -> Bottom Half를 kernel thread로 등록
- 인터럽트 발생

장점
- 높은 시스템 응답성
- 단순한 코드 작성
- IRQ 공유 용이성
- tasklet과 workqueue에 비해 스케줄링 우선순위를 세밀하게 제어할 수 있다
- 디버깅 용이성


> 실습 2206

### 키워드:

---

## 임시 이름:
memory mapped i/o macro
### 요약:
read macro

write macro
- 데이터를 쓰는 함수
- 스트림 데이터를 쓰는 함수




### 키워드:

---

## 임시 이름:
유저와 커널 공간간에 데이터 전송

### 요약:
`#include<asm/uaccess.h>`
`long access_ok` : 사용자 메모리 공간 유효성검사
`int copy_to_user` : 커널 메모리 블록 데이터를 사용자 메모리 블록 데이터에 쓰기
`int copy_from_user` : 사용자 메모리 블록 데이터를 커널 메모리 블록 데이터에 쓰기
`int get_user` : 사용자 공간의 데이터 읽기, 변수 x의 바이트 수 만큼
`int put_user` : 커널 변수 값을 사용자 공간에 쓰기, 변수 x의 바이트 수 만큼


### 키워드:

---

## 임시 이름:
ARM I/O memory

### 요약:
ARM io memory : SFR(Special Function Register)
`#include<asm/io.h>`

`void *iormap`
`void *iounmap`

메모리 매핑
`mmap()` : UserSpace 

`ioremap()` : KernelSpace



`remap_pfn_`

> 실습 2308/2311

### 키워드:

---

## 임시 이름:
ssd1306 사용해보기

### 요약:
i2c, spi


프레임 버퍼로 전송해보기(mmap, ioremap)
> 2302 04 05 06 07

### 키워드:


---

## 임시 이름:
인터럽트의 발생과 코어로의 전달 과정
### 요약:
device -> interrupt request(irq) -> iterrupt controller(NVIC) -> processor(core)

core -> exception(@ARM) -> EVT -> interrupt handler -> ask No. to NVIC -> IVT(No) -> isr

call isr(@driver)


### 키워드:

---

## 임시 이름:
kthread
### 요약:
프로세스 상태 테이블
`TASK_RUNNING`
`TASK_INTERRUPTIBLE` : 어떤 조건을 만족할 때까지 중단된 상태
`TASK_UNINTERRUPTIBLE` : 중단된 상태에서 직접적인 조건 외의 개입을 허용하지 않는 상태
`TASK_STOPPED`
`TASK_ZOMBIE`


kthread 사용법
`struct task_struct *kthread_create(int (*threadfn)(void *data), void *data, const char namefmt[], ...)`
`kthread_run()`
`kthread_stop()`
`bool kthread_should_stop(void)`
`void kthread_bind` : 스레드가 사용할 cpu 지정
`init_kthread_work`
`init_kthread_worker`
`queue_kthread_work`
`flush_kthread_work`

### 키워드:

---

## 임시 이름:
커널 영역 상호 배제 도구
### 요약:
잠드는 방식의 상호 배제
semaphore : `down/interruptible/trylock/up`
mutex : `declare/declare_locked/init/init_locked/lock/trylock/unlock`

readrlock : 
- 읽기/쓰기 세마포어
- 가중치 - Reader > Wirter
- 정의 확인
- 리더용 / 라이터용

completion :
- 타임아웃(default)
- inturrptible



잠들지 않는 방식의 상호 배제 도구
spin lock :
코어가 2개 이상 필요하다

squential lock :
- 가중치 - Reader < Wirter
- 같으면서 짝수여야 reader가 작동한다?


### 키워드:


> 실습 2401 02 03 04 05 06 07

---

## 임시 이름:
Blocking I/O

### 요약:
R/W를 할 수 없을 때 발생
- Read : 읽어 갈 것이 없는 상황 (Buffer Empty)
- Write : 데이터를 쓸 수 없는 상황 (Buffer Full)

-> 프로세스는 Blocking 된다
- 실행 큐에서 제거
- 특정 이벤트가 발생하여 프로세스 상태가 바뀔 때까지

`O_NONBLOCK` : `EAGAIN`을 반환

대기큐 만들기

`<linux/wait.h>`
`wait_event(queue, condition)`
- UNITERRUPTIBLE(default)
`wait_event_interruptible(queue, condition)`
`_sync`
`all`

> 실습 2501 2502


### 키워드:
waitevent

---

## 임시 이름:
리눅스 Jiffie

### 요약:
오실레이터로 사용하는 clock은 수십 MHz(25MHz/12MHz)
오실레이터는 PLL을 거쳐 1GHz


1GHz
- 84MHz
- 32MHz
    - RTC
    - Systimer
    - TickTimer
        - Tick
            - 스케줄러용 타이머가 발생시키는 인터럽트
            - tick 한번에 interrupt 발생

jiffie
- 1 tick 당 소요되는 시간
- 1초당 발생하는 jiffie를 HZ라고 한다
    - HZ = jiffie/seconds (CONFIG_HZ = 100 @ .config)

아키텍쳐 별로 jiffie값이 다르다(보통 100~1000 jiffie)

단기 지연
`<linux/delay.h>`
- `mdelay()` : 밀리 초 단위의 지연
- `udelay()` : 마이크로 초 단위의 지연 (가장 많이 쓰임)
- `ndelay()` : 나노 초 단위의 지원
    - ndelay()는 HZ>1000이상의 시스템에서만 의미가 있음

장기지연
jiffie를 이용한 장기 지연
커널 타이머를 이용한 장기 지연

장기 지연은 다른 작업을 병행할 수 있지만 단기 지연은 공회전 하듯이 동작하여 타 작업 병행 불가능


> 실습 2601

### 키워드:

---

## 임시 이름:
High Resolution Timer

### 요약:
단기 지연을 시키면서도 다른 작업을 병행하고 싶을 때 사용

ktime_t
1ns 단위


### 키워드:
expire
---

## 임시 이름:
드라이버 모델

### 요약:
kernel module -> module_init(), module_exit()

cdev : character 장치 구조체
dev_t :

file_operations{
    .open = dev_open,
    .read
}
dev_open(){ ... }
irqreturn_t isr() { ... return irqhandled}

드라이버 모델 필요성
- 복잡해지는 장치 위상 구조
- 기능 추가 필요성 - 전원관리
- 새롭게 추가 된 드라이버 기능들
    - 전원 관리 기능
        - 시스템에 연결된 장치 연결 탐색 기능
        - USB 호스트 OFF -> 하위 디바이스들 OFF
    - 유저 영역 접근
        - 시스템 파일 시스템(Sysfs)을 통해 사용자 영역에서 시스템에 정보 접근하도록
    - 핫 플러그-인
        - 플러그 앤 플레이
    - 디바이스 클래스
        - 연결방식에 상관없이 각 디바이스를 기능적인 계층으로 구분

### 키워드:
Sysfs

---

## 임시 이름:
Sysfs 사용법
### 요약:
파일로 gpio를 건드릴 수 있다
active low
export

### 키워드:

---

## 임시 이름:
드라이버 모델 구성 요소

### 요약:
bus     : 버스
- 
device  : 장치


driver  : 장치의 입출력을 담당하는 프로그램
- `device_driver`구조체, `<linux/device.h>`
- probe
- remove
- shutdown

class   : ?
- 

### 키워드:
> 실습 3202 03
---

## 임시 이름:
kobject

### 요약:
`cdev`에 포함되어 있는 구조체

kobject의 기능
- 참조 카운트
- 참조 카운트 관리

`kset`


### 키워드:
subsystem

플랫폼 드라이버

> 실습 3301 02 03

---

## 임시 이름:
플랫폼 드라이버

### 요약:
문자/블록 - 입출력 데이터의 단위

platform driver - virtual bus ( cpu가 제공하는 버스 ), Platform bus

i2c 방식 - bus type
spi 방식 -
usb 방식 -



input 드라이버 - HID
industrialio 드라이버 -

plaform driver 등록 방식


### 키워드:


> 실습 3401 02

---

## 임시 이름:
디바이스 트리

### 요약:
1. on
2. bootloader
    - system setup {clock(PLL), DRAM controller}

    - load os(kernel8.img)  to main memory(DRAM)
    - load dtb              to main memory(DRAM)

    - handover PC to address at kernel8.omg

3. kernel8.img
    - uncompress itself
    - Image(vmlinux)
    - ...

초기 디바이스 트리는 ofs로 bootloader 단계에서 수행했다.



.dts        (board level) = .c
.dtsi       (  soc level) = .h

dtc

.fdt(firware device tree)
.dtb(device tree blob)
.dtbo(dtb overlay)


프로퍼티
- model
- compatible : 제조사,제품명을 명시
- reg
    - 주소 사이즈
  
- interrupt-controller
    - intc:
- pinctrl
- overalying


```c
acme@10000000{
    compatible = "company,deviceAAA", "company,deviceAA", "company,deviceA","..."
                    //1순위                 //2순위             //3순위
}
```

//lib/modules/..../


### 키워드:

---

## 임시 이름:
OF style match
### 요약:
1. discoverable device
    plug-play
        usb, pci - adapter interrupt ! -> enumeration ! -> device descripter

2. non-discoverable device
    device tree

platform device는 device tree와 platform driver를 매칭하여 probe함수를 호출한다



### 키워드:

> 실습 0701 02

---

## 임시 이름:
MISC 드라이버

### 요약:
MISC 계열 디바이스
캐릭터 장치 중 하나, but 엄밀히 말하면 다르다
주 번호 10번으로 지정
장치파일을 만들어 주지 않아도 됨

헤더파일
`#include<linux/miscdevice.h>`
등록 구조체
`struct miscdevice`

`int misc_register` : 등록
`int misc_deregister` : 해제

> 실습 0801



### 키워드:

---

## 임시 이름:
input 디바이스와 드라이버

### 요약:
특징
- 간헐적 데이터 발생
- 바이트 단위 데이터
- 인터럽트 기반의 동작
    -> irq line

USB 장치의 인터럽트 전송 모드는 실제 인터럽트와는 다르다

`/proc`
`/dev/input`
`/sys`

이벤트 핸들러 디바이스 드라이버
- 키보드 `kbd`
- 마우스 `mousedev`,`mice`
- 조이스틱 `joydev`
- 터치스크린 `tsdev`
- 이벤트 `evdev`

이벤트의 구분
- type
    - EV_KEY
    - EV_
    - EV_
- code
- value
- time

`intput_dev` 구조체를 사용
`input_register_device()` 함수를 이용하여 등록
`input_unregister_device()` 함수를 이용하여 해제



### 키워드:


> 실습 0802

---

## 임시 이름:
udev 연동

### 요약:
rules파일로 심볼릭 링크 지정 udev 서비스 재시작


### 키워드:

---

## 임시 이름:
I2C 통신

### 요약:

I2C(Inter IC) : 칩 간 통신
uC bus
- SDA
- SCL : clock 발생

풀업 상태

master와 slave로 구성


protocol
- master가 시작과 끝을 주도, 통신 간 클럭을 송신
- 멀티마스터 등으로 충돌 감지 -> bus arbitration
- 

속도
- standard mode : 100Kbps
- fast mode : 400Kbps
- fast mode plus : 1Mbps
- high speed mode : 3.4Mbps
- ultra fast mode : 5Mbps

SCL 타이밍에 맞춰서 SDA의 값을 스위칭

시작과 끝을 가짐

Byte단위로 데이터가 전달


`$ ls /dev | grep i2c`
`$ i2cdetect -y 1`
`$ i2cdetect -l`
`$ i2cdetect -F 1`

SMBus(subset of I2C)
variation(->PC, laptop)
- I2C의 기능을 줄여놓은 버스

`ioctl()`

`bmp280` 센서

> 실습 0906 05


### 키워드:

---

## 임시 이름:
I2C Driver

### 요약:

I2C Adapter Driver
`struct i2c_adapter` 구조체
`struct i2c_algorithm` 구조체

I2C Client Driver

### 키워드:
> 실습 0901 : Adapter

> 실습 0903 04 : Client SSD1306

---

## 임시 이름:
i2c address
### 요약:
S + 7bit + 1bit(R/W) + A

2^7개 장착 가능

SSD1306 -> 0x3C
BMP280  -> 0x76

주소 변경하는 방법


### 키워드:

0905 실습 완성하기

---

## 임시 이름:
industrial I/O
### 요약:
Linux 커널의 Subsystem
산업용 센서 및 I/O 장치들을 위한 표준화된 프레임워크

예시
- ADC : 아날로그 신호를 디지털로 변환
- DAC : 디지털 신호를 아날로그로 변환
    - PWM
- IMU : 가속도, 각속도 측정
    - 자세제어, 동작 인식
- 압력, 온도, 조도 센서 등
- 제스쳐, 화학, 의료 센서 등

통합된 API
고성능 데이터 처리
재사용 가능한 프레임워크

표준화된 인터페이스 제공
통합된 버퍼링 방식 제공

Sysfs의 방식 read
IIO 방식 read
Devicefile 방식




> 실습 1101 02 03

---

## 임시 이름:

### 요약:

### 키워드:

---
